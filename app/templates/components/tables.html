<link href="https://unpkg.com/tabulator-tables@6.3.0/dist/css/tabulator.min.css" rel="stylesheet">
<script type="text/javascript" src="https://unpkg.com/tabulator-tables@6.3.0/dist/js/tabulator.min.js"></script>

<script>
function createTable(config) {
    const {
        data,
        columns,
        headerGroups = [],  // This contains the actual colspan values
        rowNumbering = true,
        positionChange = false
    } = config;

    let currentData = [...data];

    // Get colors for groups using #2196F3 as end color
    const getGroupColors = () => {
        const endColor = '#7ec2f8';  // Bootstrap primary blue
        const startRGB = [255, 255, 255];  // white
        const endRGB = hexToRgb(endColor);
        
        return headerGroups.map((_, index) => {
            if (index === 0) return 'rgb(255, 255, 255)';  // First group is white
            if (index === headerGroups.length - 1) return endColor;  // Last group is primary blue
            
            const factor = index / (headerGroups.length - 1);
            const r = Math.round(startRGB[0] + (endRGB[0] - startRGB[0]) * factor);
            const g = Math.round(startRGB[1] + (endRGB[1] - startRGB[1]) * factor);
            const b = Math.round(startRGB[2] + (endRGB[2] - startRGB[2]) * factor);
            
            return `rgb(${r}, ${g}, ${b})`;
        });
    };

    const hexToRgb = (hex) => {
        hex = hex.replace(/^#/, '');
        const bigint = parseInt(hex, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return [r, g, b];
    };

    const colors = getGroupColors();

    // Create mappings for column colors and last group columns
    const columnColors = {};
    const lastGroupColumns = {};
    let currentColumn = 0;
    headerGroups.forEach((group, groupIndex) => {
        const isLastGroup = groupIndex === headerGroups.length - 1;
        const colspan = group.colspan || 1;  // Get actual colspan from the group
        for (let i = 0; i < colspan; i++) {
            columnColors[currentColumn] = colors[groupIndex];
            lastGroupColumns[currentColumn] = isLastGroup;
            currentColumn++;
        }
    });

    const createHeaderGroups = () => {
        if (!headerGroups || headerGroups.length === 0) return '';
        
        return `
            <tr>
                ${headerGroups.map((group, index) => `
                    <th class="text-center" 
                        colspan="${group.colspan || 1}" 
                        style="background-color: ${colors[index]}; 
                               color: ${index === headerGroups.length - 1 ? 'white' : 'black'};">
                        ${group.title || ''}
                    </th>
                `).join('')}
            </tr>
        `;
    };

    const createColumnHeaders = () => {
        return `
            <tr>
                ${columns.map((col, index) => `
                    <th class="text-center" 
                        style="background-color: ${columnColors[index]};
                               color: ${lastGroupColumns[index] ? 'white' : 'black'};
                               font-weight: ${lastGroupColumns[index] ? 'bold' : 'normal'};">
                        ${col.title || ''}
                    </th>
                `).join('')}
            </tr>
        `;
    };

    const createTableRows = () => {
        return currentData.map((row, rowIndex) => `
            <tr>
                ${columns.map((col, colIndex) => `
                    <td class="text-center" 
                        style="background-color: ${columnColors[colIndex]};
                               color: ${lastGroupColumns[colIndex] ? 'white' : 'black'};
                               font-weight: ${lastGroupColumns[colIndex] ? 'bold' : 'normal'};
                               border-right: ${(colIndex < columns.length - 1 && 
                                              columnColors[colIndex] !== columnColors[colIndex + 1]) 
                                             ? '2px solid #dee2e6' 
                                             : '1px solid #dee2e6'};">
                        ${row[colIndex] !== undefined ? row[colIndex] : ''}
                    </td>
                `).join('')}
            </tr>
        `).join('');
    };

    return `
        <table class="table">
            <thead>
                ${createHeaderGroups()}
                ${createColumnHeaders()}
            </thead>
            <tbody>
                ${createTableRows()}
            </tbody>
        </table>
    `;
}


function createTableTabulator(tableId, data) {
        // Check if the data has columns and data
        if (!data || !data.columns || !data.data) {
            console.error('Invalid data format');
            return;
        }

        // Transform the data from array format to object format
        const transformedData = data.data.map(row => {
            const obj = {};
            data.columns.forEach(colGroup => {
                if (colGroup.columns) {
                    colGroup.columns.forEach(col => {
                        obj[col.field] = row.shift(); // Remove the first element and assign it to the field
                    });
                }
            });
            return obj;
        });

        // Process columns to ensure frozen properties are set
        const processedColumns = data.columns.map(col => {
            const newCol = { ...col };
            if (newCol.columns) {
                newCol.columns = newCol.columns.map(subCol => ({ ...subCol })); // Clone sub-columns
            }
            return newCol;
        });

        // Destroy existing instance if it exists
        if (window[tableId + 'Instance']) {
            window[tableId + 'Instance'].destroy();
        }

        // Create new Tabulator instance
        window[tableId + 'Instance'] = new Tabulator(`#${tableId}`, {
            data: transformedData,
            columns: processedColumns,
            layout: "fitDataStretch",
            responsiveLayout: false,
            pagination: false,
            movableColumns: false,
            tooltips: true,
            headerSort: true,
            height: "400px",
            columnDefaults: {
                resizable: true,
                formatter: "plaintext",
                minWidth: 80,
                maxWidth: 200,
                headerHozAlign: "center",
                hozAlign: "center"
            },
            rowHeight: 40,
            theme: "bootstrap",
            cssClass: "custom-tabulator"
        });

        console.log(`Table "${tableId}" successfully created/updated`);
    }


function createTableTabulator_old(tableId, data) {
    console.log(Tabulator.version);
    try {
        // Get all field names from column definitions
        const fields = [];
        function extractFields(columns) {
            columns.forEach(col => {
                if (col.field) {
                    fields.push(col.field);
                }
                if (col.columns) {
                    extractFields(col.columns);
                }
            });
        }
        extractFields(data.columns);

        // Transform array data into object format dynamically
        const transformedData = data.data.map(row => {
            const obj = {};
            fields.forEach((field, index) => {
                obj[field] = row[index];
            });
            return obj;
        });

        // Always destroy existing instance
        if (window[tableId + 'Instance']) {
            window[tableId + 'Instance'].destroy();
        }

        // Create new Tabulator instance
        window[tableId + 'Instance'] = new Tabulator("#" + tableId, {
            data: transformedData,
            columns: data.columns,
            layout: "fitDataStretch",
            responsiveLayout: false,
            pagination: false,
            movableColumns: false,
            tooltips: true,
            headerSort: true,
            height: "400px",
            columnDefaults: {
                resizable: true,
                formatter: "plaintext",
                minWidth: 80,
                maxWidth: 200,
                headerHozAlign: "center",
                hozAlign: "center"
            },
            rowHeight: 40,
            theme: "bootstrap",
            cssClass: "custom-tabulator"
        });

        console.log(`Table "${tableId}" successfully created/updated`);
    } catch (error) {
        console.error('Error creating/updating table:', error);
        element.innerHTML = '<div class="alert alert-danger">Error loading table. Please try again.</div>';
    }
}
</script>

<style>
/* Custom Tabulator Styling */
.custom-tabulator {
    border: none;
    background-color: var(--bs-body-bg);
    font-family: var(--bs-body-font-family);
}

/* Header styling */
.custom-tabulator .tabulator-header {
    background-color: var(--bs-primary);
    color: white;
    font-weight: 500;
    border: none;
    position: sticky !important;
    top: 0;
    z-index: 10;
}

/* Frozen columns */
.custom-tabulator .tabulator-frozen {
    position: sticky !important;
}

.custom-tabulator .tabulator-frozen.tabulator-frozen-left {
    left: 0;
    border-right: 2px solid var(--bs-primary);
    z-index: 2;
}

.custom-tabulator .tabulator-frozen.tabulator-frozen-right {
    right: 0;
    border-left: 2px solid var(--bs-primary);
    z-index: 2;
}

/* Frozen headers need higher z-index */
.custom-tabulator .tabulator-header .tabulator-frozen {
    z-index: 11;
}

/* Rest of the styling */
.custom-tabulator .tabulator-row {
    border-bottom: 1px solid var(--bs-border-color);
}

.custom-tabulator .tabulator-row.tabulator-row-even {
    background-color: rgba(var(--bs-primary-rgb), 0.05);
}

.custom-tabulator .tabulator-row.tabulator-row-odd {
    background-color: var(--bs-body-bg);
}

.custom-tabulator .tabulator-row:hover {
    background-color: rgba(var(--bs-primary-rgb), 0.1);
}

/* Scrollbars */
.custom-tabulator .tabulator-tableHolder::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.custom-tabulator .tabulator-tableHolder::-webkit-scrollbar-track {
    background: var(--bs-body-bg);
}

.custom-tabulator .tabulator-tableHolder::-webkit-scrollbar-thumb {
    background: var(--bs-primary);
    border-radius: 4px;
}

/* Add horizontal scroll indicator */
.custom-tabulator .tabulator-tableHolder {
    overflow-x: auto;
    scrollbar-width: thin;
}

/* Ensure table container takes full width */
.custom-tabulator {
    width: 100% !important;
    margin: 0;
    padding: 0;
}

/* Prevent column wrapping */
.custom-tabulator .tabulator-cell {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Hide ghost columns */
.custom-tabulator .tabulator-col.tabulator-frozen[style*="visibility: hidden"],
.custom-tabulator .tabulator-cell.tabulator-frozen[style*="visibility: hidden"] {
    display: none !important;
}
</style> 