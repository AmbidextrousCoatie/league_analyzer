<link href="{{ static_url('vendor/tabulator/css/tabulator_semanticui.min.css') }}" rel="stylesheet">
<script src="{{ static_url('js/theme/color-utils.js') }}"></script>
<script type="text/javascript" src="{{ static_url('vendor/tabulator/js/tabulator.min.js') }}"></script>

<script>
function createTable(config) {
    const {
        data,
        columns,
        headerGroups = [],  // This contains the actual colspan values
        rowNumbering = true,
        positionChange = false
    } = config;

    let currentData = [...data];

    const colors = ColorUtils.getGradientColors(
        headerGroups.length, 
        ColorUtils.getThemeColor('surface') || '#ffffff', 
        ColorUtils.getThemeColor('accent') || '#7ec2f8'
    );

    // Create mappings for column colors and last group columns
    const columnColors = {};
    const lastGroupColumns = {};
    let currentColumn = 0;
    headerGroups.forEach((group, groupIndex) => {
        const isLastGroup = groupIndex === headerGroups.length - 1;
        const colspan = group.colspan || 1;  // Get actual colspan from the group
        for (let i = 0; i < colspan; i++) {
            columnColors[currentColumn] = colors[groupIndex];
            lastGroupColumns[currentColumn] = isLastGroup;
            currentColumn++;
        }
    });

    const createHeaderGroups = () => {
        if (!headerGroups || headerGroups.length === 0) return '';
        
        return `
            <tr>
                ${headerGroups.map((group, index) => `
                    <th class="text-center" 
                        colspan="${group.colspan || 1}" 
                        style="background-color: ${colors[index]}; 
                               color: ${index === headerGroups.length - 1 ? 'white' : 'black'};">
                        ${group.title || ''}
                    </th>
                `).join('')}
            </tr>
        `;
    };

    const createColumnHeaders = () => {
        return `
            <tr>
                ${columns.map((col, index) => `
                    <th class="text-center" 
                        style="background-color: ${columnColors[index]};
                               color: ${lastGroupColumns[index] ? 'white' : 'black'};
                               font-weight: ${lastGroupColumns[index] ? 'bold' : 'normal'};">
                        ${col.title || ''}
                    </th>
                `).join('')}
            </tr>
        `;
    };

    const createTableRows = () => {
        return currentData.map((row, rowIndex) => `
            <tr>
                ${columns.map((col, colIndex) => `
                    <td class="text-center" 
                        style="background-color: ${columnColors[colIndex]};
                               color: ${lastGroupColumns[colIndex] ? 'white' : 'black'};
                               font-weight: ${lastGroupColumns[colIndex] ? 'bold' : 'normal'};
                               border-right: ${(colIndex < columns.length - 1 && 
                                              columnColors[colIndex] !== columnColors[colIndex + 1]) 
                                             ? '2px solid #dee2e6' 
                                             : '1px solid #dee2e6'};">
                        ${row[colIndex] !== undefined ? row[colIndex] : ''}
                    </td>
                `).join('')}
            </tr>
        `).join('');
    };

    return `
        <table class="table">
            <thead>
                ${createHeaderGroups()}
                ${createColumnHeaders()}
            </thead>
            <tbody>
                ${createTableRows()}
            </tbody>
        </table>
    `;
}


function flattenColumnMetadata(columnGroups = []) {
    const flatColumns = [];
    columnGroups.forEach((group, groupIndex) => {
        if (Array.isArray(group.columns)) {
            group.columns.forEach((column, columnIndex) => {
                const field = column.field || `col_${groupIndex}_${columnIndex}`;
                flatColumns.push({
                    group,
                    column,
                    groupIndex,
                    columnIndex,
                    field
                });
            });
        }
    });
    return flatColumns;
}

function mapCellMetadata(cellMetadata = {}, columnOrder = []) {
    const mapped = {};
    Object.entries(cellMetadata).forEach(([key, styles]) => {
        const [rowIndexStr, colIndexStr] = key.split(':');
        const rowIndex = parseInt(rowIndexStr, 10);
        const colIndex = parseInt(colIndexStr, 10);
        const columnInfo = columnOrder[colIndex];
        if (!columnInfo || Number.isNaN(rowIndex)) {
            return;
        }
        const field = columnInfo.field;
        if (!mapped[rowIndex]) {
            mapped[rowIndex] = {};
        }
        mapped[rowIndex][field] = styles;
    });
    return mapped;
}

function applyElementStyles(element, styles = {}) {
    if (!element || !styles) {
        return;
    }
    Object.entries(styles).forEach(([property, value]) => {
        if (value !== undefined && value !== null) {
            element.style[property] = value;
        }
    });
}

function parseColumnWidth(width) {
    if (!width) {
        return undefined;
    }
    if (typeof width === 'number') {
        return width;
    }
    const parsed = parseInt(width, 10);
    return Number.isNaN(parsed) ? undefined : parsed;
}

function createTableTabulator(tableId, data, options = {}) {
    
    const settings = {
        disablePositionCircle: false,
        enableSpecialRowStyling: false,
        tooltips: true,
        teamField: null,
        ...options
    };
    const tableConfig = data.config || {};
    const isCompactLayout = tableConfig.compact === true;
    const useStripedGroups = tableConfig.stripedColGroups === true;
    // Highlighting style constants
    const HIGHLIGHT_STYLES = {
        headerBackgroundColor: 'rgba(0, 0, 0, 0.05)',
        cellBackgroundColor: 'rgba(0, 0, 0, 0.03)',
        headerFontWeight: '900',
        cellFontWeight: '700'
    };

    if (!data || !data.columns || !data.data) {
        console.error('Invalid data format for Tabulator table');
        return;
    }

    const container = document.getElementById(tableId);
    if (!container) {
        console.error(`Container "${tableId}" not found for Tabulator table`);
        return;
    }
    
    // Ensure container takes full width
    if (container.style.width === '') {
        container.style.width = '100%';
    }

    const columnOrder = flattenColumnMetadata(data.columns);
    if (!columnOrder.length) {
        console.warn('No column definitions available for Tabulator table');
        const container = document.getElementById(tableId);
        if (container) {
            const errorMsg = data.title && data.title.includes('Fehler') ? data.title : 'No column definitions available';
            container.innerHTML = `<div class="alert alert-warning">${errorMsg}</div>`;
        }
        return;
    }
    const columnLookup = columnOrder.reduce((acc, info) => {
        acc[`${info.groupIndex}-${info.columnIndex}`] = info;
        return acc;
    }, {});

    const teamFieldGuess = data.columns?.[0]?.columns?.[1]?.field || null;
    const teamField = settings.teamField || teamFieldGuess;

    const cellMetadataMap = mapCellMetadata(data.cell_metadata || {}, columnOrder);
    const rowMetadataMap = (data.row_metadata || []).reduce((acc, meta, index) => {
        acc[index] = meta || {};
        return acc;
    }, {});

    const transformedData = data.data.map((row, rowIndex) => {
        const rowObject = { __rowIndex: rowIndex };
        columnOrder.forEach((columnInfo, columnIndex) => {
            rowObject[columnInfo.field] = row[columnIndex];
        });
        if (rowMetadataMap[rowIndex]) {
            rowObject.__rowMeta = rowMetadataMap[rowIndex];
        }
        return rowObject;
    });

    // Check if all group titles are empty - if so, flatten structure (no groups)
    const hasGroupTitles = data.columns.some(group => group.title && group.title.trim() !== '');
    
    // Apply CSS classes for striped column groups before building column definitions
    if (useStripedGroups && data.columns && hasGroupTitles) {
        ColorUtils.assignGroupStripeCss(data.columns);
        ColorUtils.injectStripeCss(data.columns.length, {
            headerAlpha: isCompactLayout ? 0.55 : 0.4,
            cellAlpha: 0.25
        });
    }

    // If no group titles, flatten to direct columns (no groups)
    let tabulatorColumns;
    if (!hasGroupTitles) {
        // Flatten: extract all columns from all groups and pass directly to Tabulator
        tabulatorColumns = [];
        data.columns.forEach((group, groupIndex) => {
            if (!Array.isArray(group.columns)) {
                return;
            }
            
            const groupFrozenDirection = group.frozen === 'left' || group.frozen === 'right' ? group.frozen : null;
            const isHighlighted = group.highlighted === true;
            
            group.columns.forEach((column, columnIndex) => {
                const columnInfo = columnLookup[`${groupIndex}-${columnIndex}`];
                if (!columnInfo) {
                    return;
                }
                const field = columnInfo.field;
                const headerAlign = column.align || 'center';
                const columnStyles = column.style || {};
                
                const formatter = function(cell) {
                    const value = cell.getValue();
                    const element = cell.getElement();
                    const rowData = cell.getRow().getData();
                    const rowIdx = rowData.__rowIndex;
                    const row = cell.getRow();

                    // Add highlighting class and style to cell element if group is highlighted
                    if (isHighlighted) {
                        element.classList.add('tab-col-highlighted');
                        element.style.setProperty('font-weight', HIGHLIGHT_STYLES.cellFontWeight, 'important');
                    }

                    // Column-level inline styles
                    applyElementStyles(element, columnStyles);

                    // Cell metadata styles (heatmap colors) - apply with !important to override striping
                    const cellMeta = cellMetadataMap[rowIdx]?.[field];
                    if (cellMeta) {
                        // Apply heatmap background color with !important to override striping CSS
                        if (cellMeta.backgroundColor) {
                            element.style.setProperty('background-color', cellMeta.backgroundColor, 'important');
                        }
                        // Apply other styles normally
                        Object.entries(cellMeta).forEach(([property, value]) => {
                            if (property !== 'backgroundColor' && value !== undefined && value !== null) {
                                element.style[property] = value;
                            }
                        });
                    }

                    // Special handling for position columns
                    // Check if this is a position column by field name or by position (first column of first group)
                    const isPositionColumn = field === 'team_position' || field === 'opponent_position' || 
                                            (!settings.disablePositionCircle && groupIndex === 0 && columnIndex === 0);
                    
                    if (isPositionColumn && !settings.disablePositionCircle) {
                        let teamName = null;
                        if (field === 'team_position') {
                            // For team position, use team name from the same row
                            teamName = rowData['team_name'] || (teamField ? rowData[teamField] : null);
                        } else if (field === 'opponent_position') {
                            // For opponent position, use opponent name from the same row
                            // Always use the raw data array for reliability
                            if (rowIdx !== undefined && rowIdx >= 0 && data.data && data.data[rowIdx]) {
                                // Find the column index for opponent_name in columnOrder
                                const opponentNameIndex = columnOrder.findIndex(ci => ci.field === 'opponent_name');
                                if (opponentNameIndex >= 0 && opponentNameIndex < data.data[rowIdx].length) {
                                    const rawRow = data.data[rowIdx];
                                    teamName = rawRow[opponentNameIndex] || null;
                                    
                                    // Debug logging (remove after fixing)
                                    if (value && rowIdx < 3) { // Only log first 3 rows to avoid spam
                                        console.log(`[opponent_position] Row ${rowIdx}: opponentNameIndex=${opponentNameIndex}, rawRow[${opponentNameIndex}]=${teamName}, rowData['opponent_name']=${rowData['opponent_name']}`);
                                    }
                                } else {
                                    console.warn(`[opponent_position] Row ${rowIdx}: Invalid opponentNameIndex=${opponentNameIndex} or row length mismatch`);
                                }
                            } else {
                                // Fallback: try rowData
                                teamName = rowData['opponent_name'] || null;
                                
                                // Last resort: try to get it from the row's opponent_name cell
                                if (!teamName) {
                                    try {
                                        const opponentNameCell = row.getCell('opponent_name');
                                        if (opponentNameCell) {
                                            teamName = opponentNameCell.getValue();
                                        }
                                    } catch (e) {
                                        // Cell might not be rendered yet
                                    }
                                }
                            }
                        } else {
                            // Fallback: first column of first group (original logic)
                            teamName = teamField ? rowData[teamField] : null;
                        }
                        
                        if (teamName) {
                            // Normalize team name (trim whitespace) to ensure it matches the color map
                            const normalizedTeamName = String(teamName).trim();
                            const color = getTeamColor(normalizedTeamName);
                            // Debug logging for opponent_position
                            if (field === 'opponent_position' && rowIdx < 3) {
                                console.log(`[opponent_position] Row ${rowIdx}: teamName="${normalizedTeamName}", color="${color}", inMap=${window.ColorUtils?.teamColorMap?.[normalizedTeamName] ? 'yes' : 'no'}`);
                            }
                            return `<div class="tab-position-circle" style="background-color: ${color};">${value ?? ''}</div>`;
                        }
                    }

                    return value ?? '';
                };

                const sampleValue = transformedData.length ? transformedData[0][field] : null;
                const isNumberColumn = typeof sampleValue === 'number';
                const isStringNumber = typeof sampleValue === 'string' && !isNaN(parseFloat(sampleValue)) && isFinite(sampleValue);

                let colCssClass = column.cssClass || '';
                let colHeaderClass = column.headerClass || '';
                
                // Build CSS classes
                let cssClasses = [];
                if (column.align === 'right') {
                    cssClasses.push('text-end');
                } else if (column.align === 'left') {
                    cssClasses.push('text-start');
                } else {
                    cssClasses.push('text-center');
                }
                
                if (isHighlighted) {
                    cssClasses.push('tab-col-highlighted');
                }
                
                if (colCssClass) {
                    cssClasses.push(colCssClass);
                }

                const columnDefinition = {
                    title: column.title || '',
                    field,
                    hozAlign: headerAlign,
                    headerHozAlign: headerAlign,
                    headerSort: column.sortable !== false,
                    sorter: column.sortable === false ? undefined : (isNumberColumn || isStringNumber ? 'number' : 'string'),
                    formatter,
                    tooltip: settings.tooltips ? true : false,
                    // Add header tooltip: use explicit tooltip if provided, otherwise default to title
                    headerTooltip: (column.tooltip !== undefined && column.tooltip !== null && column.tooltip !== '') 
                        ? column.tooltip 
                        : (column.title || ''),
                    cssClass: cssClasses.join(' ') || undefined
                };

                // Set frozen on individual column if group was frozen
                if (groupFrozenDirection) {
                    columnDefinition.frozen = groupFrozenDirection;
                }

                // Column widths
                let columnWidth = parseColumnWidth(column.width);
                if (columnWidth === undefined) {
                    if (groupIndex === 0) {
                        columnWidth = 120;
                    } else {
                        columnWidth = 100;
                    }
                }

                if (columnWidth !== undefined) {
                    if (isCompactLayout) {
                        columnDefinition.width = columnWidth;
                        columnDefinition.minWidth = columnWidth;
                        columnDefinition.widthGrow = 0;
                    } else {
                        columnDefinition.minWidth = columnWidth;
                        columnDefinition.widthGrow = 1;
                    }
                } else if (isCompactLayout) {
                    columnDefinition.widthGrow = 0;
                }

                tabulatorColumns.push(columnDefinition);
            });
        });
    } else {
        // Normal structure with groups
        tabulatorColumns = (data.columns || []).map((group, groupIndex) => {
        if (!Array.isArray(group.columns)) {
            return null;
        }

        const groupFrozenDirection = group.frozen === 'left' || group.frozen === 'right' ? group.frozen : null;
        
        // Use backend flag for highlighting
        const isHighlighted = group.highlighted === true;

        // Build cssClass: combine striped class (already added by assignGroupStripeCss) with highlight class
        let groupCssClass = group.cssClass || '';
        if (isHighlighted) {
            groupCssClass = (groupCssClass + ' tab-group-highlighted').trim();
        }

        const groupDefinition = {
            title: group.title || '',
            headerHozAlign: 'center',
            cssClass: groupCssClass,
            columns: group.columns.map((column, columnIndex) => {
                const columnInfo = columnLookup[`${groupIndex}-${columnIndex}`];
                if (!columnInfo) {
                    return null;
                }
                const field = columnInfo.field;
                const headerAlign = column.align || 'center';
                const columnStyles = column.style || {};
                
                const formatter = function(cell) {
                    const value = cell.getValue();
                    const element = cell.getElement();
                    const rowData = cell.getRow().getData();
                    const rowIdx = rowData.__rowIndex;
                    const row = cell.getRow();

                    // Add stripe class for column group coloring; actual colors come from CSS
                    if (useStripedGroups) {
                        element.classList.add('col-group-' + groupIndex);
                    }

                    // Add highlighting class and style to cell element if group is highlighted
                    if (isHighlighted) {
                        element.classList.add('tab-col-highlighted');
                        element.style.setProperty('font-weight', HIGHLIGHT_STYLES.cellFontWeight, 'important');
                    }

                    // Column-level inline styles
                    applyElementStyles(element, columnStyles);

                    // Cell metadata styles (heatmap colors) - apply with !important to override striping
                    const cellMeta = cellMetadataMap[rowIdx]?.[field];
                    if (cellMeta) {
                        // Apply heatmap background color with !important to override striping CSS
                        if (cellMeta.backgroundColor) {
                            element.style.setProperty('background-color', cellMeta.backgroundColor, 'important');
                        }
                        // Apply other styles normally
                        Object.entries(cellMeta).forEach(([property, value]) => {
                            if (property !== 'backgroundColor' && value !== undefined && value !== null) {
                                element.style[property] = value;
                            }
                        });
                    }

                    // Special handling for position columns
                    // Check if this is a position column by field name or by position (first column of first group)
                    const isPositionColumn = field === 'team_position' || field === 'opponent_position' || 
                                            (!settings.disablePositionCircle && columnInfo.groupIndex === 0 && columnInfo.columnIndex === 0);
                    
                    if (isPositionColumn && !settings.disablePositionCircle) {
                        let teamName = null;
                        if (field === 'team_position') {
                            // For team position, use team name from the same row
                            teamName = rowData['team_name'] || (teamField ? rowData[teamField] : null);
                        } else if (field === 'opponent_position') {
                            // For opponent position, use opponent name from the same row
                            // Always use the raw data array for reliability
                            if (rowIdx !== undefined && rowIdx >= 0 && data.data && data.data[rowIdx]) {
                                // Find the column index for opponent_name in columnOrder
                                const opponentNameIndex = columnOrder.findIndex(ci => ci.field === 'opponent_name');
                                if (opponentNameIndex >= 0 && opponentNameIndex < data.data[rowIdx].length) {
                                    const rawRow = data.data[rowIdx];
                                    teamName = rawRow[opponentNameIndex] || null;
                                    
                                    // Debug logging (remove after fixing)
                                    if (value && rowIdx < 3) { // Only log first 3 rows to avoid spam
                                        console.log(`[opponent_position] Row ${rowIdx}: opponentNameIndex=${opponentNameIndex}, rawRow[${opponentNameIndex}]=${teamName}, rowData['opponent_name']=${rowData['opponent_name']}`);
                                    }
                                } else {
                                    console.warn(`[opponent_position] Row ${rowIdx}: Invalid opponentNameIndex=${opponentNameIndex} or row length mismatch`);
                                }
                            } else {
                                // Fallback: try rowData
                                teamName = rowData['opponent_name'] || null;
                                
                                // Last resort: try to get it from the row's opponent_name cell
                                if (!teamName) {
                                    try {
                                        const opponentNameCell = row.getCell('opponent_name');
                                        if (opponentNameCell) {
                                            teamName = opponentNameCell.getValue();
                                        }
                                    } catch (e) {
                                        // Cell might not be rendered yet
                                    }
                                }
                            }
                        } else {
                            // Fallback: first column of first group (original logic)
                            teamName = teamField ? rowData[teamField] : null;
                        }
                        
                        if (teamName) {
                            // Normalize team name (trim whitespace) to ensure it matches the color map
                            const normalizedTeamName = String(teamName).trim();
                            const color = getTeamColor(normalizedTeamName);
                            // Debug logging for opponent_position
                            if (field === 'opponent_position' && rowIdx < 3) {
                                console.log(`[opponent_position] Row ${rowIdx}: teamName="${normalizedTeamName}", color="${color}", inMap=${window.ColorUtils?.teamColorMap?.[normalizedTeamName] ? 'yes' : 'no'}`);
                            }
                            return `<div class="tab-position-circle" style="background-color: ${color};">${value ?? ''}</div>`;
                        }
                    }

                    return value ?? '';
                };

                const sampleValue = transformedData.length ? transformedData[0][field] : null;
                const isNumberColumn = typeof sampleValue === 'number';
                // Check if it's a string that represents a number (e.g., "100.0", "99.5")
                const isStringNumber = typeof sampleValue === 'string' && !isNaN(parseFloat(sampleValue)) && isFinite(sampleValue);

                // Build column cssClass: combine striped class with any existing
                // cssClass applies to cells, headerClass applies to column headers
                // If striping is enabled, assignGroupStripeCss already added col-group-N to column.cssClass
                // But we also need to add it here in case the backend column object wasn't modified
                let colCssClass = column.cssClass || '';
                let colHeaderClass = column.headerClass || '';
                
                // Ensure stripe class is added if striping is enabled
                if (useStripedGroups) {
                    const stripeClass = 'col-group-' + groupIndex;
                    if (!colCssClass.includes(stripeClass)) {
                        colCssClass = (colCssClass + ' ' + stripeClass).trim();
                    }
                    if (!colHeaderClass.includes(stripeClass)) {
                        colHeaderClass = (colHeaderClass + ' ' + stripeClass).trim();
                    }
                }

                const columnDefinition = {
                    title: column.title || '',
                    field,
                    hozAlign: headerAlign,
                    headerHozAlign: headerAlign,
                    headerSort: column.sortable !== false,
                    // Use numeric sorter for both numbers and string numbers
                    sorter: column.sortable === false ? undefined : (isNumberColumn || isStringNumber ? 'number' : 'string'),
                    formatter,
                    tooltip: settings.tooltips ? true : false,
                    // Add header tooltip: use explicit tooltip if provided, otherwise default to title
                    headerTooltip: (column.tooltip !== undefined && column.tooltip !== null && column.tooltip !== '') 
                        ? column.tooltip 
                        : (column.title || ''),
                    cssClass: colCssClass || undefined
                };

                // Adjust column widths based on group
                // First group (Rang/Position) should be wider, week/total groups should be compressed
                let columnWidth = parseColumnWidth(column.width);
                
                if (columnWidth === undefined) {
                    // Apply default widths based on group
                    const groupTitle = (group.title || '').toLowerCase();
                    const isWeekGroup = groupTitle.includes('week') || groupTitle.includes('woche');
                    const isTotalGroup = groupTitle.includes('total') || groupTitle.includes('gesamt') || groupTitle.includes('summe');
                    
                    if (groupIndex === 0) {
                        // First group (Rang) - make it wider
                        columnWidth = 120;
                    } else if (isWeekGroup || isTotalGroup) {
                        // Week and Total groups - compress them
                        columnWidth = 80;
                    } else {
                        // Default width for other groups
                        columnWidth = 100;
                    }
                }

                if (columnWidth !== undefined) {
                    if (isCompactLayout) {
                        columnDefinition.width = columnWidth;
                        columnDefinition.minWidth = columnWidth;
                        columnDefinition.widthGrow = 0;
                    } else {
                        columnDefinition.minWidth = columnWidth; // Set minimum width, allow expansion
                        columnDefinition.widthGrow = 1; // Allow column to grow proportionally
                    }
                } else if (isCompactLayout) {
                    columnDefinition.widthGrow = 0;
                }

                // Build CSS classes
                let cssClasses = [];
                if (column.align === 'right') {
                    cssClasses.push('text-end');
                } else if (column.align === 'left') {
                    cssClasses.push('text-start');
                } else {
                    cssClasses.push('text-center');
                }
                
                // Add highlighting class if group is highlighted
                if (isHighlighted) {
                    cssClasses.push('tab-col-highlighted');
                }
                
                columnDefinition.cssClass = cssClasses.join(' ');

                return columnDefinition;
            }).filter(Boolean)
        };

        // Set frozen on the parent group, not individual columns
        if (groupFrozenDirection) {
            groupDefinition.frozen = groupFrozenDirection;
        }

        return groupDefinition;
        }).filter(Boolean);
    }

    if (!tabulatorColumns.length) {
        console.warn('No Tabulator column definitions could be created');
        return;
    }

    if (window[tableId + 'Instance']) {
        window[tableId + 'Instance'].destroy();
    }

    const tooltipOption = settings.tooltips
        ? function(cell) {
            const value = cell.getValue();
            if (value === null || value === undefined) {
                return '';
            }
            if (typeof value === 'object') {
                try {
                    return JSON.stringify(value);
                } catch (e) {
                    return '';
                }
            }
            return String(value);
        }
        : false;

    // Set up initial sort if specified
    const initialSort = data.default_sort ? [
        {
            column: data.default_sort.field,
            dir: data.default_sort.dir || "desc"  // Default to descending
        }
    ] : undefined;

    // Extract teams from data and update team color map
    // This ensures team colors are available when rendering tables on direct navigation
    // Skip if disableTeamColorUpdate is set (e.g., when handling multiple tables manually)
    if (!settings.disableTeamColorUpdate) {
        let teams = [];
        if (data.data && data.data.length > 0) {
            // Check if this is a team vs team comparison table (has "Team vs Team Comparison" in title)
            if (data.title && (data.title.includes('Team vs Team Comparison') || data.title.includes('Team vs Team Vergleichsmatrix'))) {
                teams = data.data.map(row => row[0]).filter(team => team && typeof team === 'string');
            } else {
                // Standard tables with team names in second column (index 1)
                teams = data.data.map(row => row[1]).filter(team => team && typeof team === 'string');
                
                // For game overview tables, also extract opponent names (typically in last column)
                // Check if we have an opponent_name field in columnOrder
                const opponentNameIndex = columnOrder.findIndex(ci => ci.field === 'opponent_name');
                if (opponentNameIndex >= 0) {
                    const opponentTeams = data.data.map(row => row[opponentNameIndex]).filter(team => team && typeof team === 'string');
                    teams = [...teams, ...opponentTeams];
                }
            }
            
            // Remove duplicates
            teams = [...new Set(teams)];
            
            if (teams.length > 0 && typeof window.updateTeamColorMap === 'function') {
                window.updateTeamColorMap(teams);
            }
        }
    }

    const tabulatorOptions = {
        data: transformedData,
        columns: tabulatorColumns,
        layout: isCompactLayout ? "fitData" : "fitColumns",
        responsiveLayout: false,
        pagination: false,
        movableColumns: false,
        tooltips: tooltipOption,
        height: "auto",
        rowHeight: 40,
        theme: "semanticui",
        cssClass: "custom-tabulator",
        columnHeaderVertAlign: "middle",
        width: "100%", // Ensure table takes full width of container
        ...(initialSort ? { initialSort: initialSort } : {}),
        tableBuilt: function() {
            try {
                // Apply highlighting and fix header separator
                // Use requestAnimationFrame for better timing
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                    const tableElement = document.querySelector(`#${tableId}`);
                    if (!tableElement) {
                        return;
                    }
                    
                    // Set CSS custom properties for highlighting styles
                    tableElement.style.setProperty('--highlight-header-bg', HIGHLIGHT_STYLES.headerBackgroundColor);
                    tableElement.style.setProperty('--highlight-cell-bg', HIGHLIGHT_STYLES.cellBackgroundColor);
                    tableElement.style.setProperty('--highlight-header-weight', HIGHLIGHT_STYLES.headerFontWeight);
                    tableElement.style.setProperty('--highlight-cell-weight', HIGHLIGHT_STYLES.cellFontWeight);
                    
                    // Stripe coloring: assign group classes to column group headers
                    // (cells and column headers get classes via cssClass/headerClass in column definitions)
                    if (useStripedGroups) {
                        tableElement.querySelectorAll('.tabulator-col-group').forEach((el, idx) => {
                            el.classList.add('col-group-' + idx);
                        });
                    }
                    
                    // Build map of highlighted fields and groups
                    const highlightedFields = new Set();
                    const highlightedGroupTitles = new Set();
                    data.columns.forEach((group, groupIndex) => {
                        if (group.highlighted === true && group.columns) {
                            highlightedGroupTitles.add(group.title || '');
                            group.columns.forEach(col => {
                                if (col.field) {
                                    highlightedFields.add(col.field);
                                }
                            });
                        }
                    });
                    
                    const header = tableElement.querySelector('.tabulator-header');
                    if (header) {
                        
                        // Remove full-width border from header containers
                        header.style.setProperty('border-bottom', 'none', 'important');
                        const headerContents = header.querySelector('.tabulator-header-contents');
                        if (headerContents) {
                            headerContents.style.setProperty('border-bottom', 'none', 'important');
                        }
                        const headers = header.querySelector('.tabulator-headers');
                        if (headers) {
                            headers.style.setProperty('border-bottom', 'none', 'important');
                        }
                        
                        // Apply highlighting using multiple strategies for reliability
                        if (highlightedFields.size > 0) {
                            // Strategy 1: Find groups by data-highlighted attribute in title
                            header.querySelectorAll('.tabulator-col-group').forEach((colGroup, groupIndex) => {
                                const groupTitle = colGroup.querySelector('.tab-group-title[data-highlighted="true"]');
                                if (groupTitle || highlightedGroupTitles.has(colGroup.getAttribute('aria-title') || '')) {
                                    colGroup.classList.add('tab-group-highlighted');
                                    
                                    // Style all columns within this group
                                    const cols = colGroup.querySelectorAll('.tabulator-col');
                                    cols.forEach(col => {
                                        col.classList.add('tab-col-highlighted');
                                        const colTitle = col.querySelector('.tabulator-col-title');
                                        if (colTitle) {
                                            colTitle.style.setProperty('font-weight', HIGHLIGHT_STYLES.headerFontWeight, 'important');
                                        }
                                    });
                                    
                                    // Style group title - only font-weight, no background
                                    const titleElement = colGroup.querySelector('.tabulator-col-title, .tab-group-title');
                                    if (titleElement) {
                                        titleElement.style.setProperty('font-weight', HIGHLIGHT_STYLES.headerFontWeight, 'important');
                                    }
                                }
                            });
                            
                            // Strategy 2: Find columns by field attribute
                            header.querySelectorAll('.tabulator-col[tabulator-field]').forEach(col => {
                                const field = col.getAttribute('tabulator-field');
                                if (field && highlightedFields.has(field)) {
                                    col.classList.add('tab-col-highlighted');
                                    const colTitle = col.querySelector('.tabulator-col-title');
                                    if (colTitle) {
                                        colTitle.style.setProperty('font-weight', HIGHLIGHT_STYLES.headerFontWeight, 'important');
                                    }
                                }
                            });
                        }

                    }
                    
                    // Apply highlighting to body cells using field names
                    if (highlightedFields.size > 0) {
                        const table = tableElement.querySelector('.tabulator-table');
                        if (table) {
                            const rows = table.querySelectorAll('.tabulator-row');
                            let highlightedCellCount = 0;
                            rows.forEach(row => {
                                const cells = row.querySelectorAll('.tabulator-cell');
                                cells.forEach(cell => {
                                    const field = cell.getAttribute('tabulator-field');
                                    if (!field) {
                                        return;
                                    }
                                    if (highlightedFields.has(field)) {
                                        cell.classList.add('tab-col-highlighted');
                                        cell.style.setProperty('font-weight', HIGHLIGHT_STYLES.cellFontWeight, 'important');
                                        highlightedCellCount++;
                                    }
                                });
                            });
                        }

                        // Column stripes handled via CSS classes
                    }
                });
            });
            } catch (error) {
                console.error(`[Tabulator ${tableId}] Error in tableBuilt callback:`, error);
            }
        },
        dataRendered: function() {
            // Re-apply highlighting after data is rendered (for dynamic updates)
            const tableElement = document.querySelector(`#${tableId}`);
            if (!tableElement) return;
            
            // Re-check and hide empty group headers (in case table was re-rendered)
            const header = tableElement.querySelector('.tabulator-header');
            if (header) {
                const hasGroupTitles = data.columns.some(group => group.title && group.title.trim() !== '');
                if (!hasGroupTitles) {
                    const headerRows = header.querySelector('.tabulator-header-rows');
                    if (headerRows) {
                        const rows = headerRows.querySelectorAll('.tabulator-header-row');
                        rows.forEach(row => {
                            const colGroups = row.querySelectorAll('.tabulator-col-group');
                            if (colGroups.length > 0) {
                                let allEmpty = true;
                                colGroups.forEach(colGroup => {
                                    const titleEl = colGroup.querySelector('.tabulator-col-group-title, .tabulator-col-title');
                                    if (titleEl && titleEl.textContent && titleEl.textContent.trim() !== '') {
                                        allEmpty = false;
                                    }
                                });
                                if (allEmpty) {
                                    row.style.setProperty('display', 'none', 'important');
                                    row.style.setProperty('height', '0', 'important');
                                    row.style.setProperty('min-height', '0', 'important');
                                }
                            }
                        });
                    }
                }
            }
            
            const highlightedFields = new Set();
            data.columns.forEach((group) => {
                if (group.highlighted === true && group.columns) {
                    group.columns.forEach(col => {
                        if (col.field) {
                            highlightedFields.add(col.field);
                        }
                    });
                }
            });
            
            if (highlightedFields.size > 0) {
                const table = tableElement.querySelector('.tabulator-table');
                if (table) {
                    const rows = table.querySelectorAll('.tabulator-row');
                    rows.forEach(row => {
                        const cells = row.querySelectorAll('.tabulator-cell');
                        cells.forEach(cell => {
                            const field = cell.getAttribute('tabulator-field');
                                if (field && highlightedFields.has(field)) {
                                    cell.classList.add('tab-col-highlighted');
                                    cell.style.setProperty('background-color', HIGHLIGHT_STYLES.cellBackgroundColor, 'important');
                                    cell.style.setProperty('font-weight', HIGHLIGHT_STYLES.cellFontWeight, 'important');
                                    cell.style.setProperty('color', 'inherit', 'important');
                                }
                        });
                    });
                }
            }
        },
        rowFormatter: function(row) {
            if (!settings.enableSpecialRowStyling) {
                const element = row.getElement();
                element.classList.remove('tab-row-accent');
                element.style.removeProperty('--row-accent-color');
                element.style.removeProperty('--row-accent-overlay');
            }

            const rowData = row.getData();
            const styling = rowData?.__rowMeta?.styling;
            if (styling) {
                applyElementStyles(row.getElement(), styling);
            }

            if (teamField && rowData[teamField]) {
                const accentColor = getTeamColor(rowData[teamField]);
                if (accentColor) {
                    const element = row.getElement();
                    element.classList.add('tab-row-accent');
                    element.style.setProperty('--row-accent-color', accentColor);
                    const overlay = ColorUtils.toRgba(accentColor, 0.12);
                    if (overlay) {
                        element.style.setProperty('--row-accent-overlay', overlay);
                    }
                }
            } else {
                const element = row.getElement();
                element.classList.remove('tab-row-accent');
                element.style.removeProperty('--row-accent-color');
                element.style.removeProperty('--row-accent-overlay');
            }
        }
    };

    const tabulatorInstance = new Tabulator(`#${tableId}`, tabulatorOptions);
    window[tableId + 'Instance'] = tabulatorInstance;

    console.log(`Table "${tableId}" successfully created/updated (Tabulator)`);
    
    // Register tableBuilt callback AFTER instantiation (as shown in funsies.html)
    // This is more reliable than passing it as an option
    tabulatorInstance.on("tableBuilt", function() {
        try {
            // Check if all group titles are empty - if so, hide the group header row
            const hasGroupTitles = data.columns.some(group => group.title && group.title.trim() !== '');
            
            if (!hasGroupTitles) {
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        const tableElement = document.querySelector(`#${tableId}`);
                        if (!tableElement) return;
                        
                        const header = tableElement.querySelector('.tabulator-header');
                        if (!header) return;
                        
                        // Check if all group titles are empty
                        let allGroupTitlesEmpty = true;
                        data.columns.forEach((group) => {
                            if (group.title && group.title.trim() !== '') {
                                allGroupTitlesEmpty = false;
                            }
                        });
                        
                        if (allGroupTitlesEmpty) {
                            // Structure 1: .tabulator-header-rows > .tabulator-header-row (standard structure)
                            // Hide the entire header row that contains only empty group titles
                            const headerRows = header.querySelector('.tabulator-header-rows');
                            if (headerRows) {
                                const rows = headerRows.querySelectorAll('.tabulator-header-row');
                                rows.forEach((row) => {
                                    const colGroups = row.querySelectorAll('.tabulator-col-group');
                                    if (colGroups.length > 0) {
                                        let rowAllEmpty = true;
                                        colGroups.forEach((colGroup) => {
                                            const titleEl = colGroup.querySelector('.tabulator-col-group-title');
                                            const titleText = titleEl ? titleEl.textContent.trim() : '';
                                            if (titleText !== '') {
                                                rowAllEmpty = false;
                                            }
                                        });
                                        if (rowAllEmpty) {
                                            // Hide the entire header row (this is the group title row)
                                            // Column headers are in a separate row below
                                            row.style.setProperty('display', 'none', 'important');
                                            row.style.setProperty('height', '0', 'important');
                                            row.style.setProperty('min-height', '0', 'important');
                                        }
                                    }
                                });
                            }
                            
                            // Structure 2: col-groups directly in header (alternative structure)
                            // Check if column headers are children of col-groups or separate
                            const colGroups = header.querySelectorAll('.tabulator-col-group');
                            colGroups.forEach((colGroup, idx) => {
                                const groupTitleEl = colGroup.querySelector('.tabulator-col-group-title');
                                const titleText = groupTitleEl ? groupTitleEl.textContent.trim() : '';
                                const columnHeaders = colGroup.querySelectorAll('.tabulator-col');
                                
                                if (titleText === '') {
                                    if (columnHeaders.length > 0) {
                                        // Column headers ARE children of col-group - we can't hide the col-group
                                        // Instead, hide only the title element and minimize the col-group height
                                        if (groupTitleEl) {
                                            groupTitleEl.style.setProperty('display', 'none', 'important');
                                            groupTitleEl.style.setProperty('height', '0', 'important');
                                        }
                                        // Minimize col-group but keep it visible for column headers
                                        colGroup.style.setProperty('min-height', '0', 'important');
                                        colGroup.style.setProperty('padding-top', '0', 'important');
                                        colGroup.style.setProperty('padding-bottom', '0', 'important');
                                    } else {
                                        // No column headers in col-group - safe to hide entire col-group
                                        colGroup.style.setProperty('display', 'none', 'important');
                                        colGroup.style.setProperty('height', '0', 'important');
                                        colGroup.style.setProperty('min-height', '0', 'important');
                                        colGroup.style.setProperty('padding', '0', 'important');
                                        colGroup.style.setProperty('margin', '0', 'important');
                                    }
                                }
                            });
                        }
                    });
                });
            }
            
            // Add tooltips to all column headers (ensure all headers have tooltips)
            // This ensures tooltips work even if headerTooltip property didn't apply
            requestAnimationFrame(() => {
                const tableElement = document.querySelector(`#${tableId}`);
                if (!tableElement) return;
                
                const allColumnHeaders = tableElement.querySelectorAll('.tabulator-col');
                allColumnHeaders.forEach((colElement) => {
                    // Skip if already has a tooltip
                    if (colElement.getAttribute('title')) {
                        return;
                    }
                    
                    const titleElement = colElement.querySelector('.tabulator-col-title');
                    if (!titleElement) {
                        return;
                    }
                    
                    // Get the column title text
                    const titleText = titleElement.textContent || titleElement.innerText || '';
                    if (!titleText.trim()) {
                        return;
                    }
                    
                    let tooltipText = titleText.trim();
                    
                    // Find the corresponding column definition to get explicit tooltip if available
                    const field = colElement.getAttribute('tabulator-field');
                    if (field && data.columns) {
                        // Search for explicit tooltip in column definitions
                        for (const group of data.columns) {
                            if (group.columns) {
                                for (const col of group.columns) {
                                    if (col.field === field) {
                                        if (col.tooltip !== undefined && col.tooltip !== null) {
                                            tooltipText = col.tooltip;
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Set tooltip on both the column element and title element
                    colElement.setAttribute('title', tooltipText);
                    titleElement.setAttribute('title', tooltipText);
                });
            });
        } catch (error) {
            console.error(`[Tabulator ${tableId}] Error in tableBuilt event handler:`, error);
        }
    });
}

function createTableBootstrap3(tableId, data, options = {}) {
    // Check if the data has columns and data
    if (!data || !data.columns || !data.data) {
        console.error('Invalid data format');
        return;
    }

    // Normalize columns: if bare Column objects are provided (have 'field' but no 'columns'),
    // wrap them in a ColumnGroup with empty title to match expected structure
    if (data.columns.length > 0 && data.columns[0].field && !data.columns[0].columns) {
        // These are bare Column objects, wrap them in a single group
        data.columns = [{
            title: "",
            columns: data.columns
        }];
    }

    // Get table configuration
    const config = data.config || {};
    
    // Get options with defaults
    const { disablePositionCircle = false, mergeCells = false, enableSpecialRowStyling = false } = options;
    
    // Initialize team colors if this is a table with team data
    if (data.data && data.data.length > 0 && data.data[0].length > 1) {
        // Extract team names from the data
        // For most tables, team name is in the second column (row[1])
        // For team vs team comparison, team name is in the first column (row[0])
        let teams = [];
        
        
        // Check if this is a team vs team comparison table (has "Team vs Team Comparison" in title)
        if (data.title && data.title.includes('Team vs Team Comparison')) {
            teams = data.data.map(row => row[0]).filter(team => team && typeof team === 'string');
        } else {
            // Standard tables with team names in second column
            teams = data.data.map(row => row[1]).filter(team => team && typeof team === 'string');
        }
        
        if (teams.length > 0 && typeof window.updateTeamColorMap === 'function') {
            window.updateTeamColorMap(teams);
        }
    }
    
    // Create table wrapper for horizontal scroll
    const tableWrapper = document.createElement('div');
    tableWrapper.className = 'table-responsive';

    // Create table
    const table = document.createElement('table');
    table.className = 'table';
    if (config.striped) table.classList.add('table-striped');
    if (config.hover) table.classList.add('table-hover');
    if (config.compact) table.classList.add('table-sm');
    table.style.borderCollapse = 'collapse';

    // Add title and description if provided
    if (data.title || data.description) {
        const titleDiv = document.createElement('div');
        titleDiv.className = 'mb-3';
        
        if (data.title) {
            const titleElement = document.createElement('h4');
            titleElement.textContent = data.title;
            titleElement.className = 'mb-1';
            titleDiv.appendChild(titleElement);
        }
        
        if (data.description) {
            const descElement = document.createElement('p');
            descElement.textContent = data.description;
            descElement.className = 'text-muted';
            titleDiv.appendChild(descElement);
        }
        
        document.getElementById(tableId).appendChild(titleDiv);
    }

    // Create header
    const thead = document.createElement('thead');
    if (config.stickyHeader) {
        thead.style.position = 'sticky';
        thead.style.top = '0';
        thead.style.zIndex = '2';
        thead.style.backgroundColor = '#fff';
    }

    // Check if any group has a non-empty title - only show group header row if at least one title exists
    const hasGroupTitles = data.columns.some(colGroup => colGroup.title && colGroup.title.trim() !== '');
    
    // Add group headers (only if at least one group has a title)
    if (hasGroupTitles) {
        const groupHeaderRow = document.createElement('tr');
        data.columns.forEach((colGroup, groupIndex) => {
            const th = document.createElement('th');
            th.textContent = colGroup.title || '';
            th.colSpan = colGroup.columns ? colGroup.columns.length : 1;
            th.style.padding = '8px';
            th.style.textAlign = 'center';
            th.className = 'align-middle';
            
            // Add vertical borders between groups
            if (groupIndex > 0) {
                th.style.borderLeft = `2px solid ${ColorUtils.getThemeColor('border') || '#264653'}`;
            }
            
            // Apply group styles
            if (colGroup.style) {
                Object.entries(colGroup.style).forEach(([key, value]) => {
                    th.style[key] = value;
                });
            }
            
            // Apply header styles
            if (colGroup.headerStyle) {
                Object.entries(colGroup.headerStyle).forEach(([key, value]) => {
                    th.style[key] = value;
                });
            }
            
            // Apply group width
            if (colGroup.width) {
                th.style.width = colGroup.width;
            }
            
            // Freeze column group headers if the group is frozen
            if (colGroup.frozen) {
                th.style.position = 'sticky';
                if (colGroup.frozen === 'left') {
                    // Calculate left position based on previous frozen groups
                    let leftPos = 0;
                    for (let g = 0; g < groupIndex; g++) {
                        if (data.columns[g].frozen === 'left') {
                            // Sum up widths of all columns in previous frozen groups
                            data.columns[g].columns.forEach(c => {
                                leftPos += parseInt(c.width || '100px');
                            });
                        }
                    }
                    th.style.left = `${leftPos}px`;
                }
                th.style.zIndex = '2';  // Higher than regular cells
                th.style.backgroundColor = colGroup.style?.backgroundColor || (ColorUtils.getThemeColor('surface') || '#fff');
            }
            
            groupHeaderRow.appendChild(th);
        });
        thead.appendChild(groupHeaderRow);
    }

    // Add sub-headers with sort functionality
    const subHeaderRow = document.createElement('tr');
    let sortState = {};  // Track sort state for each column
    const lastGroupIndex = data.columns.length - 1;  // Get the index of the last group

    data.columns.forEach((colGroup, groupIndex) => {
        if (colGroup.columns) {
            colGroup.columns.forEach((col, index) => {
                const th = document.createElement('th');
                th.style.padding = '8px';
                th.style.textAlign = col.align || 'center';
                th.className = 'align-middle';
                
                // Apply column width
                if (col.width) {
                    th.style.width = col.width;
                }
                
                // Apply group styles to column headers
                if (colGroup.style) {
                    Object.entries(colGroup.style).forEach(([key, value]) => {
                        th.style[key] = value;
                    });
                }
                
                // Make sortable if specified
                if (col.sortable !== false) {
                    th.style.cursor = 'pointer';
                    
                    // Create header content with sort indicator
                    const headerContent = document.createElement('div');
                    headerContent.style.display = 'flex';
                    headerContent.style.alignItems = 'center';
                    headerContent.style.justifyContent = col.align === 'left' ? 'flex-start' : 
                                                        col.align === 'right' ? 'flex-end' : 'center';
                    headerContent.style.gap = '8px';
                    
                    const titleSpan = document.createElement('span');
                    titleSpan.textContent = col.title || '';
                    // Add tooltip to header: use explicit tooltip if provided, otherwise default to title
                    const tooltipText = (col.tooltip !== undefined && col.tooltip !== null) 
                        ? col.tooltip 
                        : col.title || '';
                    if (tooltipText) {
                        th.setAttribute('title', tooltipText);
                    }
                    headerContent.appendChild(titleSpan);
                    
                    const sortIcon = document.createElement('span');
                    sortIcon.style.width = '12px';
                    sortIcon.style.height = '12px';
                    sortIcon.style.display = 'inline-block';
                    sortIcon.style.opacity = '0.5';
                    sortIcon.innerHTML = '';  // Default sort icon
                    headerContent.appendChild(sortIcon);
                    
                    th.appendChild(headerContent);
                    
                    // Add sort functionality
                    const columnId = `${groupIndex}-${index}`;
                    th.addEventListener('click', () => {
                        // Toggle sort direction or set to asc if not sorted
                        if (!sortState[columnId]) {
                            sortState = {};  // Reset other sorts
                            sortState[columnId] = 'asc';
                        } else if (sortState[columnId] === 'asc') {
                            sortState = {};  // Reset other sorts
                            sortState[columnId] = 'desc';
                        } else {
                            delete sortState[columnId];  // Remove sort
                        }
                        
                        // Update sort icons
                        document.querySelectorAll('th span:last-child').forEach(icon => {
                            icon.innerHTML = '';
                            icon.style.opacity = '0.5';
                        });
                        
                        if (sortState[columnId]) {
                            sortIcon.innerHTML = sortState[columnId] === 'asc' ? '' : '';
                            sortIcon.style.opacity = '1';
                        }
                        
                        // Sort the data
                        if (sortState[columnId]) {
                            const flatIndex = getFlatColumnIndex(data.columns, groupIndex, index);
                            const direction = sortState[columnId] === 'asc' ? 1 : -1;
                            
                            data.data.sort((a, b) => {
                                const aVal = a[flatIndex];
                                const bVal = b[flatIndex];
                                
                                // Handle different data types
                                if (typeof aVal === 'number' && typeof bVal === 'number') {
                                    return (aVal - bVal) * direction;
                                } else {
                                    const aStr = String(aVal || '');
                                    const bStr = String(bVal || '');
                                    return aStr.localeCompare(bStr) * direction;
                                }
                            });
                        }
                        
                        // Update the table body
                        updateTableBody(data.data, enableSpecialRowStyling);
                    });
                } else {
                    th.textContent = col.title || '';
                    // Add tooltip to header: use explicit tooltip if provided, otherwise default to title
                    const tooltipText = (col.tooltip !== undefined && col.tooltip !== null) 
                        ? col.tooltip 
                        : col.title || '';
                    if (tooltipText) {
                        th.setAttribute('title', tooltipText);
                    }
                }
                
                // Add vertical borders between groups
                if (index === 0 && groupIndex > 0) {
                    th.style.borderLeft = `2px solid ${ColorUtils.getThemeColor('border') || '#264653'}`;
                }
                
                // Freeze column headers if the group is frozen
                if (colGroup.frozen) {
                    th.style.position = 'sticky';
                    if (colGroup.frozen === 'left') {
                        // Calculate left position based on previous frozen columns
                        let leftPos = 0;
                        for (let g = 0; g < groupIndex; g++) {
                            if (data.columns[g].frozen === 'left') {
                                data.columns[g].columns.forEach(c => {
                                    leftPos += parseInt(c.width || '100px');
                                });
                            }
                        }
                        // Add offset for current group's previous columns
                        for (let i = 0; i < index; i++) {
                            leftPos += parseInt(colGroup.columns[i].width || '100px');
                        }
                        th.style.left = `${leftPos}px`;
                    }
                    th.style.zIndex = '2';  // Higher than regular cells
                    th.style.backgroundColor = colGroup.style?.backgroundColor || (ColorUtils.getThemeColor('surface') || '#fff');
                }
                
                subHeaderRow.appendChild(th);
            });
        }
    });
    thead.appendChild(subHeaderRow);
    table.appendChild(thead);

    // Create body
    const tbody = document.createElement('tbody');
    table.appendChild(tbody);

    // Helper function to get flat column index
    function getFlatColumnIndex(columns, groupIndex, colIndex) {
        let flatIndex = 0;
        for (let g = 0; g < groupIndex; g++) {
            flatIndex += columns[g].columns ? columns[g].columns.length : 1;
        }
        return flatIndex + colIndex;
    }

    // Function to update table body with current data
    function updateTableBody(tableData, enableSpecialRowStyling) {
        tbody.innerHTML = '';  // Clear existing rows
        
        if (mergeCells) {
            // Handle merged cells logic
            updateTableBodyWithMergedCells(tableData);
        } else {
            // Original logic for regular tables
            updateTableBodyRegular(tableData, enableSpecialRowStyling);
        }
    }
    
    // Function to update table body with merged cells
    function updateTableBodyWithMergedCells(tableData) {
        // Group rows by pairs (every 2 rows form a match)
        const groupedRows = [];
        for (let i = 0; i < tableData.length; i += 2) {
            if (i + 1 < tableData.length) {
                groupedRows.push([
                    { rowData: tableData[i], rowIndex: i },
                    { rowData: tableData[i + 1], rowIndex: i + 1 }
                ]);
            }
        }
        
        // Create rows for each group
        groupedRows.forEach((rows) => {
            if (rows.length === 2) { // We expect exactly 2 rows per match
                const [row1, row2] = rows;
                const tr1 = document.createElement('tr');
                const tr2 = document.createElement('tr');
                
                let colIndex = 0;
                
                data.columns.forEach((colGroup, groupIndex) => {
                    if (colGroup.columns) {
                        colGroup.columns.forEach((col, index) => {
                            const flatIndex = colIndex++;
                            
                            // Check if this is the first column of the first group (round number) - should be merged
                            const isRoundNumberColumn = groupIndex === 0 && index === 0;
                            
                            // Check if this is the second column of the first group (opponent name) - should be merged
                            const isOpponentColumn = groupIndex === 0 && index === 1;
                            
                            // Check if this is the third column of the first group (total points) - should be merged
                            const isTotalPointsColumn = groupIndex === 0 && index === 2;
                            
                            // Check if this is a points column (last column in each group except the first)
                            const isPointsColumn = col.field && col.field.includes('points') && col.field !== 'total_points';
                            
                            // Check if this is a team points column (should be merged)
                            const isTeamPointsColumn = col.field === 'team_points';
                            
                            if (isRoundNumberColumn) {
                                // Merge round number column - only show in first row
                                const td1 = document.createElement('td');
                                td1.style.padding = '8px';
                                td1.style.textAlign = 'center';
                                td1.style.verticalAlign = 'middle';
                                td1.setAttribute('rowspan', '2'); // Merge 2 rows
                                td1.textContent = row1.rowData[flatIndex];
                                
                                // Apply styles
                                if (col.style) {
                                    Object.entries(col.style).forEach(([key, value]) => {
                                        td1.style[key] = value;
                                    });
                                }
                                
                                if (colGroup.style) {
                                    Object.entries(colGroup.style).forEach(([key, value]) => {
                                        td1.style[key] = value;
                                    });
                                }
                                
                                tr1.appendChild(td1);
                                // Don't add to tr2 since it's merged
                            } else if (isOpponentColumn) {
                                // Merge opponent column - only show in second row
                                const td1 = document.createElement('td');
                                td1.style.padding = '8px';
                                td1.style.textAlign = 'center';
                                td1.style.verticalAlign = 'middle';
                                td1.setAttribute('rowspan', '2'); // Merge 2 rows
                                td1.textContent = row2.rowData[flatIndex]; // Use second row data (opponent name)
                                
                                // Apply styles
                                if (col.style) {
                                    Object.entries(col.style).forEach(([key, value]) => {
                                        td1.style[key] = value;
                                    });
                                }
                                
                                if (colGroup.style) {
                                    Object.entries(colGroup.style).forEach(([key, value]) => {
                                        td1.style[key] = value;
                                    });
                                }
                                
                                tr1.appendChild(td1);
                                // Don't add to tr2 since it's merged
                            } else if (isTotalPointsColumn) {
                                // Merge total points column - only show own team's total points
                                const td1 = document.createElement('td');
                                td1.style.padding = '8px';
                                td1.style.textAlign = 'center';
                                td1.style.verticalAlign = 'middle';
                                td1.setAttribute('rowspan', '2'); // Merge 2 rows
                                
                                // Get own team's total points (first row)
                                const ownTeamTotalPoints = row1.rowData[flatIndex];
                                td1.textContent = ownTeamTotalPoints;
                                
                                // Apply styles
                                if (col.style) {
                                    Object.entries(col.style).forEach(([key, value]) => {
                                        td1.style[key] = value;
                                    });
                                }
                                
                                if (colGroup.style) {
                                    Object.entries(colGroup.style).forEach(([key, value]) => {
                                        td1.style[key] = value;
                                    });
                                }
                                
                                // Format values
                                if (col.format && typeof ownTeamTotalPoints === 'number') {
                                    try {
                                        td1.textContent = col.format.replace('{:,}', ownTeamTotalPoints.toLocaleString())
                                                                   .replace('{:.1f}', ownTeamTotalPoints.toFixed(1))
                                                                   .replace('{:.2f}', ownTeamTotalPoints.toFixed(2));
                                    } catch (e) {
                                        td1.textContent = ownTeamTotalPoints;
                                    }
                                }
                                
                                tr1.appendChild(td1);
                                // Don't add to tr2 since it's merged
                            } else if (isPointsColumn || isTeamPointsColumn) {
                                // Merge points columns - only show own team's points
                                const td1 = document.createElement('td');
                                td1.style.padding = '8px';
                                td1.style.textAlign = 'center';
                                td1.style.verticalAlign = 'middle';
                                td1.setAttribute('rowspan', '2'); // Merge 2 rows
                                
                                // Get own team's points (first row)
                                const ownTeamPoints = row1.rowData[flatIndex];
                                td1.textContent = ownTeamPoints;
                                
                                // Apply styles
                                if (col.style) {
                                    Object.entries(col.style).forEach(([key, value]) => {
                                        td1.style[key] = value;
                                    });
                                }
                                
                                if (colGroup.style) {
                                    Object.entries(colGroup.style).forEach(([key, value]) => {
                                        td1.style[key] = value;
                                    });
                                }
                                
                                // Format values
                                if (col.format && typeof ownTeamPoints === 'number') {
                                    try {
                                        td1.textContent = col.format.replace('{:,}', ownTeamPoints.toLocaleString())
                                                                   .replace('{:.1f}', ownTeamPoints.toFixed(1))
                                                                   .replace('{:.2f}', ownTeamPoints.toFixed(2));
                                    } catch (e) {
                                        td1.textContent = ownTeamPoints;
                                    }
                                }
                                
                                tr1.appendChild(td1);
                                // Don't add to tr2 since it's merged
                            } else {
                                // Regular columns - create cells for both rows
                                const td1 = document.createElement('td');
                                const td2 = document.createElement('td');
                                
                                td1.style.padding = '8px';
                                td2.style.padding = '8px';
                                td1.style.textAlign = col.align || 'center';
                                td2.style.textAlign = col.align || 'center';
                                
                                const value1 = row1.rowData[flatIndex];
                                const value2 = row2.rowData[flatIndex];
                                
                        // Special handling for team vs team comparison table (takes precedence)
                        if (data.title && (data.title.includes('Team vs Team Comparison') || data.title.includes('Team vs Team Vergleichsmatrix')) && groupIndex === 0 && index === 0) {
                                    // Special handling for team vs team comparison table - first column shows team name with color
                                    const teamName1 = value1;
                                    const teamName2 = value2;
                                    
                                    let color1 = "#888"; // fallback color
                                    let color2 = "#888"; // fallback color
                                    
                                    if (typeof window.getTeamColor === 'function') {
                                        color1 = window.getTeamColor(teamName1);
                                        color2 = window.getTeamColor(teamName2);
                                    } else if (window.teamColorMap) {
                                        color1 = window.teamColorMap[teamName1] || "#888";
                                        color2 = window.teamColorMap[teamName2] || "#888";
                                    }
                                    
                                    td1.innerHTML = `<div style="display: flex; align-items: center;">
                                        <div style="width: 16px; height: 16px; border-radius: 50%; background-color: ${color1}; margin-right: 8px;"></div>
                                        <span>${teamName1}</span>
                                    </div>`;
                                    td2.innerHTML = `<div style="display: flex; align-items: center;">
                                        <div style="width: 16px; height: 16px; border-radius: 50%; background-color: ${color2}; margin-right: 8px;"></div>
                                        <span>${teamName2}</span>
                                    </div>`;
                                } else if (groupIndex === 0 && index === 0 && !disablePositionCircle) {
                                    // Handle position circle for first column of first group - regular tables
                                    const color1 = getTeamColor(row1.rowData[1]);
                                    const color2 = getTeamColor(row2.rowData[1]);
                                    td1.innerHTML = `<div style="width: 24px; height: 24px; border-radius: 50%; background-color: ${color1}; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; margin: 0 auto;">${value1}</div>`;
                                    td2.innerHTML = `<div style="width: 24px; height: 24px; border-radius: 50%; background-color: ${color2}; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; margin: 0 auto;">${value2}</div>`;
                                } else {
                                    td1.textContent = value1;
                                    td2.textContent = value2;
                                }
                                
                                // Apply styles
                                if (col.style) {
                                    Object.entries(col.style).forEach(([key, value]) => {
                                        td1.style[key] = value;
                                        td2.style[key] = value;
                                    });
                                }
                                
                                if (colGroup.style) {
                                    Object.entries(colGroup.style).forEach(([key, value]) => {
                                        td1.style[key] = value;
                                        td2.style[key] = value;
                                    });
                                }
                                
                                // Format values
                                if (col.format && typeof value1 === 'number') {
                                    try {
                                        td1.textContent = col.format.replace('{:,}', value1.toLocaleString())
                                                                   .replace('{:.1f}', value1.toFixed(1))
                                                                   .replace('{:.2f}', value1.toFixed(2));
                                    } catch (e) {
                                        td1.textContent = value1;
                                    }
                                }
                                
                                if (col.format && typeof value2 === 'number') {
                                    try {
                                        td2.textContent = col.format.replace('{:,}', value2.toLocaleString())
                                                                   .replace('{:.1f}', value2.toFixed(1))
                                                                   .replace('{:.2f}', value2.toFixed(2));
                                    } catch (e) {
                                        td2.textContent = value2;
                                    }
                                }
                                
                                // Add borders
                                if (index === 0 && groupIndex > 0) {
                                    td1.style.borderLeft = `2px solid ${ColorUtils.getThemeColor('border') || '#264653'}`;
                                    td2.style.borderLeft = `2px solid ${ColorUtils.getThemeColor('border') || '#264653'}`;
                                }
                                
                                tr1.appendChild(td1);
                                tr2.appendChild(td2);
                            }
                        });
                    }
                });
                
                tbody.appendChild(tr1);
                tbody.appendChild(tr2);
            }
        });
    }
    
    // Function to update table body with regular logic (original implementation)
    function updateTableBodyRegular(tableData, enableSpecialRowStyling) {
        tableData.forEach((rowData, rowIndex) => {
            const tr = document.createElement('tr');
            
            let colIndex = 0;  // Track the flat column index
            
            // Apply styling based on metadata if available and special styling is enabled
            if (enableSpecialRowStyling && data.row_metadata && data.row_metadata[rowIndex]) {
                const rowMetadata = data.row_metadata[rowIndex];
                const styling = rowMetadata.styling || {};
                
                // Apply row-level styles
                Object.entries(styling).forEach(([key, value]) => {
                    tr.style[key] = value;
                });
            }
            
            data.columns.forEach((colGroup, groupIndex) => {
                if (colGroup.columns) {
                    colGroup.columns.forEach((col, index) => {
                        const td = document.createElement('td');
                        td.style.padding = '8px';
                        td.style.textAlign = col.align || 'center';
                        
                        // Get the value for this cell
                        const value = rowData[colIndex];
                        colIndex++;
                        // Apply dynamic heat map colors based on cell value (for sorting compatibility)
                        if (data.metadata && data.metadata.score_range && data.metadata.points_range) {
                            if (value === "") {
                                // Empty cells (diagonal) get light gray background
                                td.style.backgroundColor = ColorUtils.getThemeColor('background') || "#f8f9fa";
                            } else {
                                const cellValue = parseFloat(value);
                                if (!isNaN(cellValue)) {
                                    // Determine if this is a score or points column based on column position
                                    // Skip the first column (team name) - colIndex starts at 1 after team name
                                    const adjustedColIndex = colIndex - 1; // Adjust for team name column
                                    // Based on debug output: Col 4 (adjustedColIndex 3) has score 751, Col 5 (adjustedColIndex 4) has points 5
                                    // So the pattern is: Score (odd adjustedColIndex), Points (even adjustedColIndex)
                                    const isScoreColumn = adjustedColIndex % 2 === 1; // Score columns are odd positions (1, 3, 5, 7...)
                                    const isPointsColumn = adjustedColIndex % 2 === 0; // Points columns are even positions (0, 2, 4, 6...)
                                    
                                    if (isScoreColumn && data.metadata.score_range) {
                                        const color = ColorUtils.getHeatMapColor(cellValue, data.metadata.score_range.min, data.metadata.score_range.max);
                                        td.style.backgroundColor = color;
                                    } else if (isPointsColumn && data.metadata.points_range) {
                                        const color = ColorUtils.getHeatMapColor(cellValue, data.metadata.points_range.min, data.metadata.points_range.max);
                                        td.style.backgroundColor = color;
                                    }
                                }
                            }
                        } else {
                            // Fallback to original cell_metadata approach if no metadata available
                            if (data.cell_metadata && data.cell_metadata[`${rowIndex}:${colIndex}`]) {
                                const cellMeta = data.cell_metadata[`${rowIndex}:${colIndex}`];
                                Object.entries(cellMeta).forEach(([key, value]) => {
                                    td.style[key] = value;
                                });
                            }
                        }
                        
                        // Now increment colIndex
                        
                        
                        // Special handling for team vs team comparison table (takes precedence)
                        if (data.title && (data.title.includes('Team vs Team Comparison') || data.title.includes('Team vs Team Vergleichsmatrix')) && groupIndex === 0 && index === 0) {
                            // Special handling for team vs team comparison table - first column shows team name with color
                            const teamName = value;
                            let color = "#888"; // fallback color
                            
                            if (typeof window.getTeamColor === 'function') {
                                color = window.getTeamColor(teamName);
                            } else if (window.teamColorMap && window.teamColorMap[teamName]) {
                                color = window.teamColorMap[teamName];
                            }
                            
                            td.innerHTML = `<div style="display: flex; align-items: center;">
                                <div style="width: 16px; height: 16px; border-radius: 50%; background-color: ${color}; margin-right: 8px;"></div>
                                <span>${teamName}</span>
                            </div>`;
                        } else if (groupIndex === 0 && index === 0 && !disablePositionCircle) {
                            // Special handling for position column (first column of first group) - regular tables
                            // Use the position value (not team name) for the circle
                            const color = getTeamColor(rowData[1]); // Still use team name for color
                            td.innerHTML = `<div style="width: 24px; height: 24px; border-radius: 50%; background-color: ${color}; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; margin: 0 auto;">${value}</div>`;
                        } else {
                            td.textContent = value;
                        }
                        
                        // Apply cell-level styling based on metadata if available and special styling is enabled
                        if (enableSpecialRowStyling && data.row_metadata && data.row_metadata[rowIndex]) {
                            const rowMetadata = data.row_metadata[rowIndex];
                            const styling = rowMetadata.styling || {};
                            
                            // Apply cell-level styles (like fontWeight)
                            if (styling.fontWeight) {
                                td.style.fontWeight = styling.fontWeight;
                            }
                        }
                        
                        // Apply column styles
                        if (col.style) {
                            Object.entries(col.style).forEach(([key, value]) => {
                                td.style[key] = value;
                            });
                        }
                        
                        // Apply group styles to cells
                        if (colGroup.style) {
                            Object.entries(colGroup.style).forEach(([key, value]) => {
                                td.style[key] = value;
                            });
                        }
                        
                        // Format the value if specified
                        if (col.format && typeof value === 'number') {
                            try {
                                td.textContent = col.format.replace('{:,}', value.toLocaleString())
                                                         .replace('{:.1f}', value.toFixed(1))
                                                         .replace('{:.2f}', value.toFixed(2));
                            } catch (e) {
                                console.error('Error formatting value:', e);
                                td.textContent = value;
                            }
                        }
                        
                        // Add vertical borders between groups (including between Team and first opponent)
                        if (index === 0 && groupIndex > 0) {
                            td.style.borderLeft = `2px solid ${ColorUtils.getThemeColor('border') || '#264653'}`;
                        }
                        
                        // Freeze columns if specified
                        if (colGroup.frozen) {
                            td.style.position = 'sticky';
                            if (colGroup.frozen === 'left') {
                                // Calculate left position based on previous frozen columns
                                let leftPos = 0;
                                for (let g = 0; g < groupIndex; g++) {
                                    if (data.columns[g].frozen === 'left') {
                                        data.columns[g].columns.forEach(c => {
                                            leftPos += parseInt(c.width || '100px');
                                        });
                                    }
                                }
                                // Add offset for current group's previous columns
                                for (let i = 0; i < index; i++) {
                                    leftPos += parseInt(colGroup.columns[i].width || '100px');
                                }
                                td.style.left = `${leftPos}px`;
                                
                                // Remove ALL visual separation
                                td.style.boxShadow = 'none';
                                td.style.borderRight = 'none';
                                td.style.borderLeft = 'none';
                            }
                            td.style.zIndex = '1';
                            td.style.backgroundColor = colGroup.style?.backgroundColor || (ColorUtils.getThemeColor('surface') || '#fff');
                        }
                        
                        tr.appendChild(td);
                    });
                }
            });
            
            tbody.appendChild(tr);
        });
    }
    
    // Initial population of table body
    updateTableBody(data.data, enableSpecialRowStyling);
    
    tableWrapper.appendChild(table);
    document.getElementById(tableId).innerHTML = '';  // Clear existing content
    document.getElementById(tableId).appendChild(tableWrapper);
    
    console.log(`Table "${tableId}" successfully created/updated`);
}


// Function to fetch and render a table with loading state
function fetchAndRenderTable(tableId, url, params = {}) {
    // Show loading spinner
    const container = document.getElementById(tableId);
    container.innerHTML = `
        <div class="text-center p-5">
            <div class="spinner-border text-primary" role="status"></div>
            <p class="mt-2">Loading data...</p>
        </div>
    `;
    
    // Build query string from params
    const queryString = Object.keys(params)
        .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`)
        .join('&');
    
    // Fetch data
    fetch(`${url}?${queryString}`)
        .then(response => {
            if (!response.ok) {
                // Create error object with status for better handling
                const error = new Error(`HTTP error! Status: ${response.status}`);
                error.status = response.status;
                throw error;
            }
            return response.json();
        })
        .then(data => {
            // Check if data indicates no results
            if (data.message && data.message.includes('No data found')) {
                throw new Error('No data found for these parameters');
            }
            // Render the table with the fetched data - use Tabulator by default
            if (typeof createTableTabulator === 'function') {
                createTableTabulator(tableId, data, {
                    ...params.options,
                    tooltips: true
                });
            } else if (typeof createTableBootstrap3 === 'function') {
                // Fallback to Bootstrap if Tabulator not available
                createTableBootstrap3(tableId, data, params.options || {});
            } else {
                console.error('No table creation function available');
                container.innerHTML = '<div class="alert alert-warning">Table creation function not available</div>';
            }
        })
        .catch(error => {
            console.error('Error fetching table data:', error);
            
            // Show appropriate error message based on error type
            const container = document.getElementById(tableId);
            if (error.status === 404 || error.message.includes('No data found')) {
                container.innerHTML = `
                    <div class="alert alert-warning">
                        <strong>Data Unavailable:</strong> No data found for the current parameters.
                        <br><small>This might be due to a data source change. Try refreshing the page or selecting different parameters.</small>
                    </div>
                `;
            } else {
                container.innerHTML = `
                    <div class="alert alert-danger">
                        <strong>Error:</strong> Failed to load table data. ${error.message}
                        <br><small>Please try refreshing the page or contact support if the problem persists.</small>
                    </div>
                `;
            }
        });
}

// Function to get team color
function getTeamColor(teamName) {
    if (window.ColorUtils && typeof window.ColorUtils.getTeamColor === 'function') {
        return window.ColorUtils.getTeamColor(teamName);
    }
    return '#888';
}
</script>

<style>
/* Table theme with light/dark support */
:root {
    --table-surface: var(--theme-surface, #ffffff);
    --table-surface-alt: #f6f8fb;
    --table-border-soft: rgba(15, 23, 42, 0.08);
    --table-header-bg: #eef2f7;
    --table-header-text: #0f172a;
    --table-body-text: var(--theme-table-body-text, #1f2933);
    --table-muted-text: #64748b;
    --table-hover-bg: rgba(59, 130, 246, 0.08);
    --table-selected-bg: rgba(99, 102, 241, 0.18);
    --table-highlight-bg: rgba(15, 118, 110, 0.12);
    --table-shadow: 0 12px 25px rgba(15, 23, 42, 0.08);
}

/* Dark mode styles are now applied via ColorUtils.applyDarkMode() */
/* This selector is kept for compatibility but colors come from CSS variables */
body.dark-mode,
body[data-theme="dark"],
:root[data-theme="dark"] {
    /* Colors are set via CSS variables by ColorUtils */
}

.custom-tabulator {
    border: none;
    background: transparent;
    font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
    color: var(--table-body-text);
}

.custom-tabulator .tabulator-tableHolder {
    border-radius: 16px;
    background: var(--table-surface);
    box-shadow: var(--table-shadow);
    border: 1px solid var(--table-border-soft);
    overflow: hidden;
}

.custom-tabulator .tabulator-header {
    background: linear-gradient(120deg, var(--table-header-bg), transparent);
    color: var(--table-header-text);
    border: none;
    border-bottom: none !important; /* Remove full-width separator */
    padding: 4px 0;
}

/* Semantic UI theme customizations - black borders for column groups and columns */
.custom-tabulator .tabulator-header .tabulator-col-group,
.custom-tabulator .tabulator-header .tabulator-col {
    border-bottom: 2px solid #000000 !important;
    border-bottom-color: #000000 !important;
}

.custom-tabulator .tabulator-col {
    border: none;
    background: transparent;
}

.custom-tabulator .tabulator-col .tabulator-col-content {
    padding: 0.85rem 0.75rem;
    font-weight: 600;
    letter-spacing: 0.02em;
}

.custom-tabulator .tabulator-row {
    background: var(--table-surface);
    border: none;
    color: var(--table-body-text);
    transition: background 160ms ease;
    position: relative;
    overflow: hidden;
}

.custom-tabulator .tabulator-row:nth-child(even) {
    background: var(--table-surface-alt);
}

.custom-tabulator .tabulator-row .tabulator-cell {
    border: none;
    padding: 0.85rem 0.75rem;
    font-size: 0.95rem;
}

.custom-tabulator .tabulator-row:hover {
    background: var(--table-hover-bg);
}

.custom-tabulator .tabulator-row.tab-row-accent::before {
    content: "";
    position: absolute;
    left: 8px;
    top: 12px;
    bottom: 12px;
    width: 4px;
    border-radius: 999px;
    background: var(--row-accent-color, transparent);
    opacity: 0.9;
}

.custom-tabulator .tabulator-row.tab-row-accent {
    padding-left: calc(0.85rem + 6px);
    background-image: linear-gradient(90deg, var(--row-accent-overlay, rgba(0,0,0,0.02)), transparent 65%);
}

.dark-mode .custom-tabulator .tabulator-row.tab-row-accent,
[data-theme="dark"] .custom-tabulator .tabulator-row.tab-row-accent {
    background-image: linear-gradient(90deg, var(--row-accent-overlay, rgba(255,255,255,0.06)), transparent 65%);
}

.custom-tabulator .tabulator-row.tabulator-selected {
    background: var(--table-selected-bg);
}

.custom-tabulator .tabulator-frozen {
    box-shadow: inset -1px 0 var(--table-border-soft);
    z-index: 10;
}

/* Frozen Tabulator cells: force solid background so nothing shows through on scroll */
.custom-tabulator .tabulator-row .tabulator-cell.tabulator-frozen {
    background-color: var(--table-surface) !important;
}

.custom-tabulator .tabulator-row:nth-child(even) .tabulator-cell.tabulator-frozen {
    background-color: var(--table-surface-alt) !important;
}

/* Frozen Tabulator headers: also force solid background (no transparent overlay) */
.custom-tabulator .tabulator-header .tabulator-col.tabulator-frozen,
.custom-tabulator .tabulator-header .tabulator-col-group.tabulator-frozen {
    background-color: var(--table-header-bg) !important;
}

.custom-tabulator .tabulator-placeholder {
    background: var(--table-surface);
    color: var(--table-muted-text);
}

.custom-tabulator .tabulator-footer {
    background: var(--table-surface);
    border: none;
    color: var(--table-muted-text);
}

.tab-position-circle {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    font-weight: 600;
    margin: 0 auto;
    font-size: 0.85rem;
}

/* Hover Effects */
.custom-tabulator .tabulator-row:hover {
    background-color: rgba(38, 70, 83, 0.1); /* Light hover effect */
}

/* Frozen Column Styles */
.custom-tabulator .tabulator-frozen {
    background-color: var(--theme-surface, #ffffff); /* Background for frozen columns */
    z-index: 10; /* Ensure frozen columns are above others */
}

/* Scrollbar Styles */
.custom-tabulator .tabulator-tableHolder::-webkit-scrollbar {
    width: 8px; /* Width of the scrollbar */
}

.custom-tabulator .tabulator-tableHolder::-webkit-scrollbar-track {
    background: #f1f1f1; /* Track color */
}

.custom-tabulator .tabulator-tableHolder::-webkit-scrollbar-thumb {
    background: var(--theme-border, #264653); /* Thumb color */
    border-radius: 4px; /* Rounded corners */
}

.custom-tabulator .tabulator-tableHolder::-webkit-scrollbar-thumb:hover {
    background: rgba(38, 70, 83, 0.8); /* Darker thumb on hover */
}

/* Column group styling */
.custom-tabulator .tabulator-col-group {
    background-color: var(--table-header-bg) !important;
    border-bottom: 2px solid #000000 !important;
    border-bottom-color: #000000 !important;
}

.custom-tabulator .tabulator-col-group[data-group-index="0"],
.custom-tabulator .tabulator-col-group[data-group-index="1"],
.custom-tabulator .tabulator-col-group[data-group-index="2"] {
    background-color: var(--table-header-bg) !important;
    border-bottom: 2px solid #000000 !important;
    border-bottom-color: #000000 !important;
}

/* Column group titles */
.custom-tabulator .tabulator-col-group .tabulator-col-group-title {
    color: var(--table-header-text) !important;
}


.border-right {
    border-right: 1px solid var(--theme-border, #264653); /* Bootstrap's default border color */
}

.table-responsive {
    overflow-x: auto; /* Enable horizontal scrolling */
}

th {
    position: relative; /* Required for sticky positioning */
    background-color: var(--theme-background, #f8f9fa); /* Header background color */
}
/* Add more rules based on your number of groups */

/* Remove ALL visual separation between frozen and non-frozen columns
   for custom sticky layouts (Bootstrap tables etc.) */
[style*="position: sticky"] {
    box-shadow: none !important;
    border-right: none !important;
    border-left: none !important;
}

/* Remove any nth-child selectors that might be adding shadows */
tr > td:nth-child(2)[style*="position: sticky"],
tr > th:nth-child(2)[style*="position: sticky"] {
    box-shadow: none !important;
}

/* Ensure no borders between position and team columns */
tr > td:first-child,
tr > th:first-child {
    border-right: none !important;
}

tr > td:nth-child(2),
tr > th:nth-child(2) {
    border-left: none !important;
}

/* Semantic UI theme - prevent header separator from expanding */
.custom-tabulator .tabulator-header,
.custom-tabulator .tabulator-header-contents,
.custom-tabulator .tabulator-headers {
    border-bottom: none !important;
    width: 100% !important; /* Ensure header takes full width */
}

/* Only individual columns should have borders */
.custom-tabulator .tabulator-header .tabulator-col-group,
.custom-tabulator .tabulator-header .tabulator-col {
    border-bottom: 2px solid #000000 !important;
    border-bottom-color: #000000 !important;
}

/* Ensure table and table holder take full width */
.custom-tabulator {
    width: 100% !important;
}

.custom-tabulator .tabulator-tableHolder {
    width: 100% !important;
}

.custom-tabulator .tabulator-table {
    width: 100% !important;
}

/* Highlighted column group - Option 1: Subtle background + bold (CURRENT) */
/* Use high specificity to override Semantic UI theme */
/* CSS variables are set from JavaScript HIGHLIGHT_STYLES constants */
.custom-tabulator .tabulator-header .tabulator-col-group.tab-group-highlighted,
.custom-tabulator.tabulator .tabulator-header .tabulator-col-group.tab-group-highlighted,
.tabulator.custom-tabulator .tabulator-header .tabulator-col-group.tab-group-highlighted,
#testTableHighlight .tabulator-header .tabulator-col-group.tab-group-highlighted {
    background-color: var(--highlight-header-bg, rgba(0, 0, 0, 0.05)) !important;
}

/* Group title - only font-weight, background comes from parent */
.custom-tabulator .tabulator-header .tabulator-col-group.tab-group-highlighted .tabulator-col-title,
.custom-tabulator .tabulator-header .tabulator-col-group.tab-group-highlighted .tabulator-col-content .tabulator-col-title,
.custom-tabulator .tabulator-header .tabulator-col-group.tab-group-highlighted .tab-group-title,
.tabulator.custom-tabulator .tabulator-header .tabulator-col-group.tab-group-highlighted .tabulator-col-title,
#testTableHighlight .tabulator-header .tabulator-col-group.tab-group-highlighted .tabulator-col-title {
    font-weight: var(--highlight-header-weight, 900) !important;
    color: inherit !important;
}

.custom-tabulator .tabulator-header .tabulator-col.tab-col-highlighted,
.custom-tabulator.tabulator .tabulator-header .tabulator-col.tab-col-highlighted,
.tabulator.custom-tabulator .tabulator-header .tabulator-col.tab-col-highlighted {
    background-color: inherit !important;
}

/* Column title - only font-weight */
.custom-tabulator .tabulator-header .tabulator-col.tab-col-highlighted .tabulator-col-title,
.custom-tabulator .tabulator-header .tabulator-col.tab-col-highlighted .tabulator-col-content .tabulator-col-title,
.tabulator.custom-tabulator .tabulator-header .tabulator-col.tab-col-highlighted .tabulator-col-title {
    font-weight: var(--highlight-header-weight, 900) !important;
    color: inherit !important;
}

.custom-tabulator .tabulator-row .tabulator-cell.tab-col-highlighted,
.custom-tabulator.tabulator .tabulator-row .tabulator-cell.tab-col-highlighted,
.tabulator.custom-tabulator .tabulator-row .tabulator-cell.tab-col-highlighted {
    background-color: inherit !important;
    font-weight: var(--highlight-cell-weight, 700) !important;
    color: inherit !important;
}

.custom-tabulator .tabulator-col-group,
.custom-tabulator .tabulator-col {
    background-color: var(--theme-surface, #ffffff);
}

/* Alternative highlighting options (uncomment to use):
   
   Option 2: Left border accent
   .custom-tabulator .tabulator-col-group.tab-group-highlighted {
       border-left: 4px solid #000000 !important;
   }
   .custom-tabulator .tabulator-col.tab-col-highlighted {
       border-left: 4px solid #000000 !important;
   }
   
   Option 3: Darker background with white text
   .custom-tabulator .tabulator-col-group.tab-group-highlighted,
   .custom-tabulator .tabulator-col-group.tab-group-highlighted .tabulator-col-title {
       background-color: var(--theme-table-body-text, #1f2933) !important;
       color: var(--theme-text-on-primary, #ffffff) !important;
       font-weight: 700 !important;
   }
   .custom-tabulator .tabulator-col.tab-col-highlighted,
   .custom-tabulator .tabulator-col.tab-col-highlighted .tabulator-col-title {
       background-color: var(--theme-table-body-text, #1f2933) !important;
       color: var(--theme-text-on-primary, #ffffff) !important;
       font-weight: 700 !important;
   }
   .custom-tabulator .tabulator-row .tabulator-cell.tab-col-highlighted {
       background-color: var(--theme-table-body-text, #1f2933) !important;
       color: var(--theme-text-on-primary, #ffffff) !important;
       font-weight: 600 !important;
   }
   
   Option 4: Thicker border
   .custom-tabulator .tabulator-col-group.tab-group-highlighted,
   .custom-tabulator .tabulator-col.tab-col-highlighted {
       border-bottom: 3px solid #000000 !important;
       border-top: 2px solid #000000 !important;
   }
*/

</style> 