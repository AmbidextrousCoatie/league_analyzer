<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/echarts@5.6.0/dist/echarts.min.js"></script>

<script>
// --- Team Color Palettes ---
const TEAM_COLOR_PALETTES = {
  "forestWine": [
    "#463C54", "#555B6E", "#5A7D7C", "#789262", "#A3A76D",
    "#C1B97F", "#B98B6D", "#B04A5A", "#A11A3C", "#8B1534"
  ],
  "sunsetPop": [
    "#00475A", "#2B537A", "#5B4C8A", "#8B4C8A", "#C05A8A",
    "#F95D6A", "#FF8A36", "#FFB35C", "#FFD782"
  ],
  "rainbowPastel": [
    "#1B8CA6", "#2CA89A", "#8CBF8A", "#E6C86E", "#F7A86E",
    "#E86E56", "#D95A6A", "#C94C8A", "#A04CBF", "#D6A4E6"
  ],
  "distinct10": [
    "#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00",
    "#FFFF33", "#A65628", "#F781BF", "#999999", "#1B7837"
  ],
  "harmonic10": [
    "#1F77B4", "#FF7F0E", "#2CA02C", "#D62728", "#9467BD",
    "#8C564B", "#E377C2", "#7F7F7F", "#BCBD22", "#17BECF"
  ]
};

// Default palette
let currentPaletteName = "forestWine";
let currentPalette = TEAM_COLOR_PALETTES[currentPaletteName];

// --- Palette Switcher UI ---
function renderPaletteSwitcher(containerId = "paletteSwitcher") {
  const container = document.getElementById(containerId);
  if (!container) return;
  container.innerHTML = "<b>Color Palette:</b> ";
  Object.keys(TEAM_COLOR_PALETTES).forEach(name => {
    const btn = document.createElement("button");
    btn.textContent = name.replace(/([A-Z])/g, " $1").replace(/^./, s => s.toUpperCase());
    btn.onclick = () => {
      currentPaletteName = name;
      currentPalette = TEAM_COLOR_PALETTES[name];
      if (typeof window.refreshAllCharts === "function") window.refreshAllCharts();
    };
    btn.style.margin = "0 4px";
    btn.style.padding = "4px 10px";
    btn.style.borderRadius = "4px";
    btn.style.border = name === currentPaletteName ? "2px solid #222" : "1px solid #aaa";
    btn.style.background = name === currentPaletteName ? "#eee" : "#fff";
    btn.style.cursor = "pointer";
    container.appendChild(btn);
  });
}

// --- Team Color Function ---
function getTeamColor(team, idx) {
  if (typeof idx === "number") {
    return currentPalette[idx % currentPalette.length];
  }
  // Fallback: hash team name to index
  let hash = 0;
  for (let i = 0; i < team.length; i++) {
    hash = team.charCodeAt(i) + ((hash << 5) - hash);
  }
  const index = Math.abs(hash) % currentPalette.length;
  return currentPalette[index];
}

// --- Global chart refresh stub (user should implement) ---
if (!window.refreshAllCharts) {
  window.refreshAllCharts = function() {
    // User: call your chart rendering functions here to update colors
    // Example: updateTableLeagueWeek(); updateTablePosition(data); etc.
    // console.log('refreshAllCharts called');
  };
}

// --- Palette Dropdown Handler for Navbar ---
document.addEventListener("DOMContentLoaded", function() {
  renderPaletteSwitcher();
  // Palette dropdown in navbar
  document.querySelectorAll('.palette-option').forEach(function(el) {
    el.addEventListener('click', function(e) {
      e.preventDefault();
      const palette = el.getAttribute('data-palette');
      if (palette && TEAM_COLOR_PALETTES[palette]) {
        currentPaletteName = palette;
        currentPalette = TEAM_COLOR_PALETTES[palette];
        // Update navbar text
        const text = el.textContent.trim();
        const paletteText = document.getElementById('currentPaletteText');
        if (paletteText) paletteText.textContent = text;
        if (typeof window.refreshAllCharts === "function") window.refreshAllCharts();
      }
    });
  });
});

// --- NOTE: Add <div id="paletteSwitcher"></div> to your HTML where you want the palette switcher to appear. ---

// --- Update all chart color assignments below ---

// Example for createLineChart:
function createLineChart(data, order, containerId, title, labels, invertYAxis = false, yAxisRange = null) {
    const container = document.getElementById(containerId);
    
    // Dispose of existing chart instance if it exists
    const existingChart = echarts.getInstanceByDom(container);
    if (existingChart) {
        existingChart.dispose();
    }
    
    if (order == null) {
        order = Object.keys(data)
    }
    
    // Initialize new chart instance
    const chart = echarts.init(container, null, {
        devicePixelRatio: window.devicePixelRatio,
        renderer: 'canvas'
    });
    
    // Calculate y-axis range if requested
    let yMin, yMax;
    if (yAxisRange === 'auto') {
        const allValues = order.map(team => data[team]).flat();
        yMin = Math.max(Math.min(...allValues) - 10, 0);
        yMax = Math.max(...allValues) + 10;
    }

    if (yAxisRange === 'exact') {
        const allValues = order.map(team => data[team]).flat();
        yMin = Math.min(...allValues);
        yMax = Math.max(...allValues);
    }
    
    // Create series from the data using the specified order
    const series = order.map((team, idx) => {
        let seriesData = data[team];
        
        // If inverting y-axis, transform the data values
        if (invertYAxis && yAxisRange === 'exact') {
            // For position charts: invert the values so position 1 appears at the top
            // If max position is 8, then position 1 becomes 8, position 8 becomes 1, etc.
            const maxPosition = yMax;
            seriesData = data[team].map(value => maxPosition - value + 1);
        }
        
        return {
            name: team,
            type: 'line',
            data: seriesData,
            lineStyle: {
                color: getTeamColor(team, idx),
                width: 2
            },
            itemStyle: {
                color: getTeamColor(team, idx)
            },
            smooth: false
        };
    });
    
    // Chart options
    const chartOptions = {
        tooltip: {
            trigger: 'axis'
        },
        legend: {
            show: false
        },
        grid: {
            top: '10%',
            right: '5%',
            bottom: '10%',
            left: '5%',
            containLabel: true
        },
        xAxis: {
            type: 'category',
            data: labels,
            axisLine: {
                show: false
            },
            splitLine: {
                show: true
            }
        },
        yAxis: {
            type: 'value',
            min: yMin,
            max: yMax,
            axisLine: {
                show: true
            },
            axisTick: {
                show: true
            },
            splitLine: {
                show: true
            },
            axisLabel: {
                formatter: function(value) {
                    if (invertYAxis && yAxisRange === 'exact') {
                        // Show original position values on axis
                        const maxPosition = yMax;
                        return maxPosition - value + 1;
                    }
                    return value;
                }
            }
        },
        series: series,
        animation: false
    };
    
    // Set the chart options with clear flag
    chart.setOption(chartOptions, true);
    
    // Clean up old resize listener if it exists
    if (container._echartResizeHandler) {
        window.removeEventListener('resize', container._echartResizeHandler);
    }
    
    // Add new resize listener
    const resizeHandler = () => {
        chart.resize();
    };
    window.addEventListener('resize', resizeHandler);
    container._echartResizeHandler = resizeHandler;
    
    return chart;
}

function createLineChart_vanilla(data, chartId, title, labels, reverse_y) {
    const ctx = document.getElementById(chartId).getContext('2d');
    
    // Destroy existing chart if it exists
    if (window[chartId + 'Instance'] instanceof Chart) {
        window[chartId + 'Instance'].destroy();
    }
    
    // Create datasets for each team
    const datasets = Object.entries(data).map(([team, values]) => ({
        label: team,
        data: values,
        borderColor: getTeamColor(team, Object.keys(data).length),
        backgroundColor: getTeamColor(team, Object.keys(data).length),
        tension: 0.1
    }));
    
    window[chartId + 'Instance'] = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            plugins: {
                title: {
                    display: true,
                    text: title
                },
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    reverse: reverse_y,
                    beginAtZero: false,
                    ticks: {
                        stepSize: 1
                    }
                }
            }
        }
    });
}

function createScatterChart_vanilla(data, chartId, title, axis_labels) {
    const ctx = document.getElementById(chartId).getContext('2d');
    
    // Destroy existing chart if it exists
    if (window[chartId + 'Instance'] instanceof Chart) {
        window[chartId + 'Instance'].destroy();
    }
    
    // Collect all points for regression
    const allPoints = Object.values(data).flat();
    const xs = allPoints.map(point => point[0]);
    const ys = allPoints.map(point => point[1]);
    
    // Calculate regression line
    const n = xs.length;
    const sumX = xs.reduce((a, b) => a + b, 0);
    const sumY = ys.reduce((a, b) => a + b, 0);
    const sumXY = xs.reduce((sum, x, i) => sum + x * ys[i], 0);
    const sumXX = xs.reduce((sum, x) => sum + x * x, 0);
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;
    
    // Create regression line points
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const regressionLine = {
        label: 'Regression',
        data: [
            {x: minX, y: slope * minX + intercept},
            {x: maxX, y: slope * maxX + intercept}
        ],
        type: 'line',
        borderColor: '#000000',
        borderWidth: 1,
        borderDash: [5, 5],
        pointRadius: 0,
        fill: false
    };
    
    // Create datasets for each team
    const datasets = Object.entries(data).map(([team, points]) => ({
        label: team,
        data: points.map(point => ({x: point[0], y: point[1]})),
        borderColor: getTeamColor(team, Object.keys(data).length),
        backgroundColor: getTeamColor(team, Object.keys(data).length),
        pointRadius: 5
    }));
    
    // Add regression line to datasets
    datasets.push(regressionLine);
    
    window[chartId + 'Instance'] = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: datasets
        },
        options: {
            responsive: true,
            plugins: {
                title: {
                    display: true,
                    text: title
                },
                legend: {
                    display: false
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            if (context.dataset.type === 'line') {
                                return ''; // Hide tooltip for regression line
                            }
                            return `${context.dataset.label}: (${context.parsed.x.toFixed(1)}, ${context.parsed.y.toFixed(1)})`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: {
                        display: true,
                        text: axis_labels.x
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: axis_labels.y
                    }
                }
            }
        }
    });
}


function createScatterChartMultiAxis(data, order, containerId, title, labels) {
    const container = document.getElementById(containerId);
    
    console.log('Order:', order);

    // Dispose of existing chart instance if it exists
    const existingChart = echarts.getInstanceByDom(container);
    if (existingChart) {
        existingChart.dispose();
    }
    
    // Initialize new chart instance
    const chart = echarts.init(container, null, {
        devicePixelRatio: window.devicePixelRatio,
        renderer: 'canvas'
    });
    
    const teams = order;
    const singleAxis = [];
    const series = [];
    
    // Configure for each team
    teams.forEach(function (team, idx) {
        const isLastTeam = idx === teams.length - 1;
        
        singleAxis.push({
            left: 40,
            right: 40,
            type: 'category',
            boundaryGap: false,
            data: labels,
            top: (idx * 90) / teams.length + '%',
            height: (90 / teams.length) + '%',
            axisLabel: {
                show: isLastTeam,
                interval: 0
            },
            axisTick: {
                show: false
            },
            axisLine: {
                show: isLastTeam,
                lineStyle: {
                    color: isLastTeam ? '#333' : 'transparent'
                }
            },
            splitLine: {
                show: true,           // Show grid lines
                lineStyle: {
                    type: 'dashed',   // Make them dashed
                    opacity: 0.3,     // Make them semi-transparent
                    color: '#222'     // Light grey color
                }
            }
        });
        
        const seriesData = data[team].map((value, index) => [index, value]);
        
        series.push({
            name: team,
            singleAxisIndex: idx,
            coordinateSystem: 'singleAxis',
            type: 'scatter',
            data: seriesData,
            symbolSize: function(dataItem) {
                return Math.max(dataItem[1] / teams.length * 7, 10);
            },
            itemStyle: {
                color: getTeamColor(team, idx)
            }
        });
    });
    
    const chartOptions = {
        /*title: {
            text: title,
            left: 'center',
            top: 0
        },*/
        tooltip: {
            position: 'top',
            formatter: function(params) {
                return `${teams[params.seriesIndex]}<br/>
                        ${labels[params.data[0]]}<br/>
                        Punkte: ${params.data[1]}`;
            }
        },
        singleAxis: singleAxis,
        series: series
    };
    
    chart.setOption(chartOptions, true);  // Added true for clear previous option
    
    // Clean up old resize listener if it exists
    if (container._echartResizeHandler) {
        window.removeEventListener('resize', container._echartResizeHandler);
    }
    
    // Add new resize listener
    const resizeHandler = () => {
        chart.resize();
    };
    window.addEventListener('resize', resizeHandler);
    container._echartResizeHandler = resizeHandler;
    
    return chart;
}

</script>
